<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorIntegration.jl</title><meta name="title" content="API · TaylorIntegration.jl"/><meta property="og:title" content="API · TaylorIntegration.jl"/><meta property="twitter:title" content="API · TaylorIntegration.jl"/><meta name="description" content="Documentation for TaylorIntegration.jl."/><meta property="og:description" content="Documentation for TaylorIntegration.jl."/><meta property="twitter:description" content="Documentation for TaylorIntegration.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TaylorIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../taylor_method/">Taylor&#39;s method</a></li><li><a class="tocitem" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="tocitem" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../simple_example/">Infinity in finite time</a></li><li><a class="tocitem" href="../kepler/">The Kepler problem</a></li><li><a class="tocitem" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="tocitem" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="tocitem" href="../root_finding/">Poincaré maps</a></li><li><a class="tocitem" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li><a class="tocitem" href="../taylorize/">Optimizing: <code>@taylorize</code></a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PerezHz/TaylorIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><hr/><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.taylorinteg" href="#TaylorIntegration.taylorinteg"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">taylorinteg(f, x0, t0, tmax, order, abstol, params[=nothing]; kwargs... )
taylorinteg(f, x0, t0, tmax, order, abstol, Val(false), params[=nothing]; kwargs... )
taylorinteg(f, x0, t0, tmax, order, abstol, Val(true), params[=nothing]; kwargs... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(x, p, t)$</span>, where <code>p</code> are the parameters encoded in <code>params</code>. The initial conditions are specified by <code>x0</code> at time <code>t0</code>; <code>x0</code> may be of type <code>T&lt;:Number</code> or <code>Vector{T}</code>, with <code>T</code> including <code>TaylorN{T}</code>; the latter case is of interest for <a href="../jet_transport/#jettransport">jet transport applications</a>.</p><p>The equations of motion are specified by the function <code>f</code>; we follow the same convention of <code>DifferentialEquations.jl</code> to define this function, i.e., <code>f(x, p, t)</code> or <code>f!(dx, x, p, t)</code>; see the examples below.</p><p>The functions return a vector with the values of time (independent variable), and a vector with the computed values of the dependent variable(s), and if the method used involves <code>Val(true)</code> it also outputs the Taylor polynomial solutions obtained at each time step. The integration stops when time is larger than <code>tmax</code>, in which case the last returned value(s) correspond to <code>tmax</code>, or when the number of saved steps is larger than <code>maxsteps</code>.</p><p>The integration method uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>Currently, the recognized keyword arguments are:</p><ul><li><code>maxsteps[=500]</code>: maximum number of integration steps.</li><li><code>parse_eqs[=true]</code>: use the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li></ul><p><strong>Examples</strong></p><p>For one dependent variable the function <code>f</code> defines the RHS of the equation of motion, returning the value of <span>$\dot{x}$</span>. The arguments of this function are <code>(x, p, t)</code>, where <code>x</code> are the dependent variables, <code>p</code> are the paremeters and <code>t</code> is the independent variable.</p><p>For several (two or more) dependent variables, the function <code>f!</code> defines the RHS of the equations of motion, mutating (in-place) the (preallocated) vector with components of <span>$\dot{x}$</span>. The arguments of this function are <code>(dx, x, p, t)</code>, where <code>dx</code> is the preallocated vector of <span>$\dot{x}$</span>, <code>x</code> are the dependent variables, <code>p</code> are the paremeters entering the ODEs and <code>t</code> is the independent variable. The function may return this vector or simply <code>nothing</code>.</p><pre><code class="language-julia hljs">using TaylorIntegration

f(x, p, t) = x^2

tv, xv = taylorinteg(f, 3, 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )

function f!(dx, x, p, t)
    for i in eachindex(x)
        dx[i] = x[i]^2
    end
    return nothing
end

tv, xv = taylorinteg(f!, [3, 3], 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )

tv, xv, psol = taylorinteg(f!, [3, 3], 0.0, 0.3, 25, 1.0e-20, maxsteps=100, Val(true) )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.lyap_taylorinteg" href="#TaylorIntegration.lyap_taylorinteg"><code>TaylorIntegration.lyap_taylorinteg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyap_taylorinteg(f!, q0, t0, tmax, order, abstol[, jacobianfunc!=nothing];
    maxsteps::Int=500, parse_eqs::Bool=true)
lyap_taylorinteg(f!, q0, trange, order, abstol[, jacobianfunc!=nothing];
    maxsteps::Int=500, parse_eqs::Bool=true)</code></pre><p>Similar to <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for the calculation of the Lyapunov spectrum. Note that the number of <code>TaylorN</code> variables should be set previously by the user (e.g., by means of <code>TaylorSeries.set_variables</code>) and should be equal to the length of the vector of initial conditions <code>q0</code>. Otherwise, whenever <code>length(q0) != TaylorSeries.get_numvars()</code>, then <code>lyap_taylorinteg</code> throws an <code>AssertionError</code>. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to evaluate the current value of the Jacobian. Otherwise, the current value of the Jacobian is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/lyapunovspectrum.jl#L218-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.@taylorize" href="#TaylorIntegration.@taylorize"><code>TaylorIntegration.@taylorize</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><code>@taylorize expr</code></p><p>This macro <code>eval</code>s the function given by <code>expr</code> and defines a new method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>jetcoeffs!</code></a> which is specialized on that function. Integrating via <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> of <a href="#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> after using the macro yields better performance.</p><p>See the <a href="../taylorize/#taylorize">documentation</a> for more details and limitations.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This macro is on an experimental stage; check the integration results carefully.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L1160-L1174">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.BookKeeping" href="#TaylorIntegration.BookKeeping"><code>TaylorIntegration.BookKeeping</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BookKeeping</code></pre><p>Mutable struct that contains all the bookkeeping vectors/dictionaries used within <code>_make_parsed_jetcoeffs</code>:     - <code>d_indx</code>     : Dictionary mapping new variables (symbols) to old (perhaps indexed) symbols     - <code>d_assign</code>   : Dictionary with the numeric assignments (that are substituted)     - <code>d_decl</code>     : Dictionary declared arrays     - <code>v_newvars</code>  : Symbols of auxiliary indexed vars     - <code>v_arraydecl</code>: Symbols which are explicitly declared as Array or Vector     - <code>v_array1</code>   : Symbols which are explicitly declared as Array{Taylor1{T},1}     - <code>v_array2</code>   : Symbols which are explicitly declared as Array{Taylor1{T},2}     - <code>v_array3</code>   : Symbols which are explicitly declared as Array{Taylor1{T},3}     - <code>v_array4</code>   : Symbols which are explicitly declared as Array{Taylor1{T},4}     - <code>v_preamb</code>   : Symbols or Expr used in the preamble (declarations, etc)     - <code>retvar</code>     : <em>Guessed</em> returned variable, which defines the LHS of the ODEs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L8-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.RetAlloc" href="#TaylorIntegration.RetAlloc"><code>TaylorIntegration.RetAlloc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RetAlloc{Taylor1{T}}</code></pre><p>Struct related to the returned variables that are pre-allocated when <code>@taylorize</code> is used.     - <code>v0</code>   : Vector{Taylor1{T}}     - <code>v1</code>   : Vector{Vector{Taylor1{T}}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.__jetcoeffs!-Union{Tuple{U}, Tuple{Val{false}, Any, Any, Taylor1{U}, Any}} where U" href="#TaylorIntegration.__jetcoeffs!-Union{Tuple{U}, Tuple{Val{false}, Any, Any, Taylor1{U}, Any}} where U"><code>TaylorIntegration.__jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">__jetcoeffs!(::Val{false}, f, t, x, params)
__jetcoeffs!(::Val{true}, f, t, x, params, rv)
__jetcoeffs!(::Val{false}, f, t, x, dx, xaux, params)
__jetcoeffs!(::Val{true}, f, t, x, dx, params, rv)</code></pre><p>Chooses a method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>jetcoeffs!</code></a> (hard-coded) or the generated by <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>) depending on <code>Val{bool}</code> (<code>bool::Bool</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._allocated_defs!-Tuple{Expr, TaylorIntegration.BookKeeping}" href="#TaylorIntegration._allocated_defs!-Tuple{Expr, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._allocated_defs!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_allocated_defs!(new_jetcoeffs, bkkeep)</code></p><p>Add allocated variable definitions to <code>new_jetcoeffs</code>, to make it more human readable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L1096-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._capture_fn_args_body!" href="#TaylorIntegration._capture_fn_args_body!"><code>TaylorIntegration._capture_fn_args_body!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_capture_fn_args_body!(ex, dd::Dict{Symbol, Any})</code></p><p>Captures the name of a function, arguments, body and other properties, returning them as the values of the dictionary <code>dd</code>, which is updated in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._defs_allocs!" href="#TaylorIntegration._defs_allocs!"><code>TaylorIntegration._defs_allocs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_defs_allocs!(preamble, fnargs, bkkeep, [inloop=false, ex_aux::Expr(:block,)])</code></p><p>Returns a vector with expressions defining the auxiliary variables in the preamble, and the declaration of the arrays. This function may modify <code>bkkeep.d_indx</code> if new variables are introduced. <code>bkkeep.v_preamb</code> is for bookkeeping the introduced variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L874-L882">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._determine_parsing!-Tuple{Bool, Vararg{Any, 4}}" href="#TaylorIntegration._determine_parsing!-Tuple{Bool, Vararg{Any, 4}}"><code>TaylorIntegration._determine_parsing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_determine_parsing!(parse_eqs::Bool, f, t, x, params)
_determine_parsing!(parse_eqs::Bool, f, t, x, dx, params)</code></pre><p>Check if the parsed method of <code>jetcoeffs!</code> exists and check it runs without error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L283-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._extract_parts-Tuple{Expr}" href="#TaylorIntegration._extract_parts-Tuple{Expr}"><code>TaylorIntegration._extract_parts</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_extract_parts(ex::Expr)</code></p><p>Returns the function name, the function arguments, and the body of a function passed as an <code>Expr</code>. The function may be provided as a one-line function, or in the long form (anonymous functions do not work).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L214-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._make_parsed_jetcoeffs-Tuple{Expr}" href="#TaylorIntegration._make_parsed_jetcoeffs-Tuple{Expr}"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_make_parsed_jetcoeffs( ex )</code></p><p>This function constructs the expressions of two new methods, the first equivalent to the differential equations (jetcoeffs!), which exploits the mutating functions of TaylorSeries.jl, and the second one (<em>allocate</em>jetcoeffs) preallocates any auxiliary <code>Taylor1</code> or <code>Vector{Taylor1{T}}</code> needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._newfnbody!-Tuple{Any, Any, TaylorIntegration.BookKeeping}" href="#TaylorIntegration._newfnbody!-Tuple{Any, Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._newfnbody!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_newfnbody!(fnbody, fnargs, bkkeep)</code></p><p>Returns a new (modified) body of the function, a priori unfolding the expression graph (AST) as unary and binary calls, and updates the bookkeeping structure bkkeep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L400-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._newhead-Tuple{Any, Any}" href="#TaylorIntegration._newhead-Tuple{Any, Any}"><code>TaylorIntegration._newhead</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_newhead(fn, fnargs)</code></p><p>Creates the head of the new method of <code>jetcoeffs!</code> and <code>_allocate_jetcoeffs</code>. <code>fn</code> is the name of the passed function and <code>fnargs</code> is a vector with its arguments defning the function (which are either three or four).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L297-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._parse_newfnbody!-Tuple{Expr, Expr, Expr, TaylorIntegration.BookKeeping, Bool}" href="#TaylorIntegration._parse_newfnbody!-Tuple{Expr, Expr, Expr, TaylorIntegration.BookKeeping, Bool}"><code>TaylorIntegration._parse_newfnbody!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>parse</em>newfnbody!(ex::Expr, preex::Expr, prealloc::Expr, bkkeep::BookKeeping, inloop::Bool)</p><p>Parses <code>ex</code> (the new body of the function) replacing the expressions to use the mutating functions of TaylorSeries, and building the preamble <code>preex</code> and <code>prealloc</code> expressions. This is done by traversing recursively (again) the args of <code>ex</code>, updating the bookkeeping struct <code>bkkeep</code>, in particular the fieldnames <code>v_newvars</code> and <code>d_assign</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L577-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._preamble_body-Tuple{Any, Any}" href="#TaylorIntegration._preamble_body-Tuple{Any, Any}"><code>TaylorIntegration._preamble_body</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_preamble_body(fnbody, fnargs)</code></p><p>Returns expressions for the preamble, the declaration of arrays, the body and the bookkeeping struct, which will be used to build the new functions. <code>fnbody</code> is the expression with the body of the original function (already adapted), <code>fnargs</code> is a vector of symbols of the original diferential equations function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L329-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._recursionloop-Tuple{Any, TaylorIntegration.BookKeeping}" href="#TaylorIntegration._recursionloop-Tuple{Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._recursionloop</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_recursionloop(fnargs, bkkeep)</code></p><p>Build the expression for the recursion-loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L1030-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._rename_indexedvars-Tuple{Any}" href="#TaylorIntegration._rename_indexedvars-Tuple{Any}"><code>TaylorIntegration._rename_indexedvars</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_rename_indexedvars(fnbody)</code></p><p>Renames the indexed variables (using <code>Espresso.genname()</code>) that exists in <code>fnbody</code>. Returns <code>fnbody</code> with the renamed variables and a dictionary that links the new variables to the old indexed ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L380-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._replace_expr!-Tuple{Expr, Expr, Expr, Int64, Any, Any, TaylorIntegration.BookKeeping}" href="#TaylorIntegration._replace_expr!-Tuple{Expr, Expr, Expr, Int64, Any, Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._replace_expr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_replace_expr!(ex::Expr, preex::Expr, , prealloc::Expr, i::Int, aalhs, aarhs,     bkkeep::BookKeeping)</code></p><p>Replaces the calls in <code>ex.args[i]</code>, and updates <code>preex</code> and <code>prealloc</code> with the appropriate expressions, based on the the LHS (<code>aalhs</code>) and RHS (<code>aarhs</code>) of the base assignment. The bookkeeping struct is updated (<code>v_newvars</code>) within <code>_replacecalls!</code>. <code>d_indx</code> is used to bring back the indexed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L695-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._replacecalls!-Tuple{TaylorIntegration.BookKeeping, Expr, Symbol}" href="#TaylorIntegration._replacecalls!-Tuple{TaylorIntegration.BookKeeping, Expr, Symbol}"><code>TaylorIntegration._replacecalls!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_replacecalls!(bkkeep, fnold, newvar)</code></p><p>Replaces the symbols of unary and binary calls of the expression <code>fnold</code>, which defines <code>newvar</code>, by the mutating functions in TaylorSeries.jl. The vector <code>bkkeep.v_vars</code> is updated if new auxiliary variables are introduced (bookkeeping).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L753-L762">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._returned_expr-Tuple{TaylorIntegration.BookKeeping}" href="#TaylorIntegration._returned_expr-Tuple{TaylorIntegration.BookKeeping}"><code>TaylorIntegration._returned_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_returned_expr(bkkeep)</code></p><p>Constructs the expression to be returned by <code>TaylorIntegration._allocate_jetcoeffs!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L1123-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration._second_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_second_stepsize(x, epsilon)</code></pre><p>Corresponds to the &quot;second stepsize control&quot; in Jorba and Zou (2005) paper. We use it if <a href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}"><code>stepsize</code></a> returns <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._split_arraydecl!-Tuple{TaylorIntegration.BookKeeping}" href="#TaylorIntegration._split_arraydecl!-Tuple{TaylorIntegration.BookKeeping}"><code>TaylorIntegration._split_arraydecl!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_split_arraydecl!(bkkeep)</code></p><p>Split bkkeep.v<em>arraydecl in the vector (bkkeep.v</em>array1), matrix (bkkeep.v_array2), etc, to properly construct the <code>RetAlloc</code> variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L1064-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U, T, Int64}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U, T, Int64}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration._stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_stepsize(aux1, epsilon, k)</code></pre><p>Helper function to avoid code repetition. Returns <span>$(epsilon/aux1)^(1/k)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.findroot!-NTuple{18, Any}" href="#TaylorIntegration.findroot!-NTuple{18, Any}"><code>TaylorIntegration.findroot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findroot!(t, x, dx, g_tupl_old, g_tupl, eventorder, tvS, xvS, gvS,
    t0, δt_old, x_dx, x_dx_val, g_dg, g_dg_val, nrabstol,
    newtoniter, nevents) -&gt; nevents</code></pre><p>Internal root-finding subroutine, based on Newton-Raphson process. If there is a crossing, then the crossing data is stored in <code>tvS</code>, <code>xvS</code> and <code>gvS</code> and <code>nevents</code>, the number of events/crossings, is updated. Here <code>t</code> is a <code>Taylor1</code> polynomial which represents the independent variable; <code>x</code> is an array of <code>Taylor1</code> variables which represent the vector of dependent variables; <code>dx</code> is an array of <code>Taylor1</code> variables which represent the LHS of the ODE; <code>g_tupl_old</code> is the last-before-current value returned by event function <code>g</code> and <code>g_tupl</code> is the current one; <code>eventorder</code> is the order of the derivative of <code>g</code> whose roots the user is interested in finding; <code>tvS</code> stores the surface-crossing instants; <code>xvS</code> stores the value of the solution at each of the crossings; <code>gvS</code> stores the values of the event function <code>g</code> (or its <code>eventorder</code>-th derivative) at each of the crossings; <code>t0</code> is the current time; <code>δt_old</code> is the last time-step size; <code>x_dx</code>, <code>x_dx_val</code>, <code>g_dg</code>, <code>g_dg_val</code> are auxiliary variables; <code>nrabstol</code> is the Newton-Raphson process tolerance; <code>newtoniter</code> is the maximum allowed number of Newton-Raphson iteration; <code>nevents</code> is the current number of detected events/crossings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/rootfinding.jl#L36-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.inbookkeeping-Tuple{Any, TaylorIntegration.BookKeeping}" href="#TaylorIntegration.inbookkeeping-Tuple{Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration.inbookkeeping</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>inbookkeeping(v, bkkeep::BookKeeping)</code></p><p>Checks if <code>v</code> is declared in <code>bkkeep</code>, considering the <code>d_indx</code>, <code>v_newvars</code> and <code>v_arraydecl</code> fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/parse_eqs.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jetcoeffs!(eqsdiff!::Function, t, x, dx, xaux, params)</code></pre><p>Mutates <code>x</code> in-place using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(x, p, t)$</span>.</p><p><code>eqsdiff!</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variables and <code>t</code> is the independent variable, and <code>params</code> are the parameters appearing on the function defining the differential equation. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and convention for <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Vector{Taylor1{U}}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>. In this case, two auxiliary containers <code>dx</code> and <code>xaux</code> (both of the same type as <code>x</code>) are needed to avoid allocations.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, Taylor1{U}, Any}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, Taylor1{U}, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jetcoeffs!(eqsdiff::Function, t, x, params)</code></pre><p>Returns an updated <code>x</code> using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(x, p, t)$</span>.</p><p><code>eqsdiff</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variable(s) and <code>t</code> is the independent variable, and <code>params</code> are the parameters appearing on the function defining the differential equation. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and convention for <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Taylor1{U}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T}, AbstractArray{Taylor1{S}, 1}, AbstractArray{Taylor1{S}, 1}, Array{Taylor1{S}, 2}, Array{Taylor1{S}, 3}}} where {T&lt;:Real, S&lt;:Number}" href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T}, AbstractArray{Taylor1{S}, 1}, AbstractArray{Taylor1{S}, 1}, Array{Taylor1{S}, 2}, Array{Taylor1{S}, 3}}} where {T&lt;:Real, S&lt;:Number}"><code>TaylorIntegration.lyap_jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lyap_jetcoeffs!(t, x, dx, jac, varsaux)</code></pre><p>Similar to <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>jetcoeffs!</code></a> for the calculation of the Lyapunov spectrum. Updates <em>only</em> the elements of <code>x</code> which correspond to the solution of the 1st-order variational equations <span>$\dot{\xi}=J \cdot \xi$</span>, where <span>$J$</span> is the Jacobian matrix, i.e., the linearization of the equations of motion. <code>jac</code> is the Taylor expansion of <span>$J$</span> wrt the independent variable, around the current initial condition. <code>varsaux</code> is an auxiliary array of type <code>Array{eltype(jac),3}</code> to avoid allocations. Calling this method assumes that <code>jac</code> has been computed previously using <a href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any, Any}} where {T&lt;:Real, U&lt;:Number}"><code>stabilitymatrix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/lyapunovspectrum.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any, Any}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.lyap_taylorstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lyap_taylorstep!(f!, t, x, dx, xaux, δx, dδx, jac, t0, t1, order, abstol, _δv, varsaux, params[, jacobianfunc!])</code></pre><p>Similar to <a href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Taylor1{U}, T, Any}} where {T&lt;:Real, U&lt;:Number}"><code>taylorstep!</code></a> for the calculation of the Lyapunov spectrum. <code>jac</code> is the Taylor expansion (wrt the independent variable) of the linearization of the equations of motion, i.e, the Jacobian. <code>xaux</code>, <code>δx</code>, <code>dδx</code>, <code>varsaux</code> and <code>_δv</code> are auxiliary vectors, and <code>params</code> define the parameters of the ODEs. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/lyapunovspectrum.jl#L157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U, T, Int64, Int64}} where {U&lt;:Number, T&lt;:Real}" href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U, T, Int64, Int64}} where {U&lt;:Number, T&lt;:Real}"><code>TaylorIntegration.nrconvergencecriterion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nrconvergencecriterion(g_val, nrabstol::T, nriter::Int, newtoniter::Int) where {T&lt;:Real}</code></pre><p>A rudimentary convergence criterion for the Newton-Raphson root-finding process. <code>g_val</code> may be either a <code>Real</code>, <code>Taylor1{T}</code> or a <code>TaylorN{T}</code>, where <code>T&lt;:Real</code>. Returns <code>true</code> if: 1) the absolute value of <code>g_val</code>, the value of the event function <code>g</code> evaluated at the current estimated root by the Newton-Raphson process, is less than the <code>nrabstol</code> tolerance; and 2) the number of iterations <code>nriter</code> of the Newton-Raphson process is less than the maximum allowed number of iterations, <code>newtoniter</code>; otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/rootfinding.jl#L21-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any, Any}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.stabilitymatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stabilitymatrix!(eqsdiff!, t, x, δx, dδx, jac, _δv, params[, jacobianfunc!=nothing])</code></pre><p>Updates the matrix <code>jac::Matrix{Taylor1{U}}</code> (linearized equations of motion) computed from the equations of motion (<code>eqsdiff!</code>), at time <code>t</code> at <code>x</code>; <code>x</code> is of type <code>Vector{Taylor1{U}}</code>, where <code>U&lt;:Number</code>. <code>δx</code>, <code>dδx</code> and <code>_δv</code> are auxiliary arrays of type <code>Vector{TaylorN{Taylor1{U}}}</code> to avoid allocations. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/lyapunovspectrum.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stepsize(x, epsilon) -&gt; h</code></pre><p>Returns a maximum time-step for a the Taylor expansion <code>x</code> using a prescribed absolute tolerance <code>epsilon</code> and the last two Taylor coefficients of (each component of) <code>x</code>.</p><p>Note that <code>x</code> is of type <code>Taylor1{U}</code> or <code>Vector{Taylor1{U}}</code>, including also the cases <code>Taylor1{TaylorN{U}}</code> and <code>Vector{Taylor1{TaylorN{U}}}</code>.</p><p>Depending of <code>eltype(x)</code>, i.e., <code>U&lt;:Number</code>, it may be necessary to overload <code>stepsize</code>, specializing it on the type <code>U</code>, to avoid type instabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L117-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool, Taylor1{T}}, Tuple{Bool, Taylor1{T}}, Int64}} where T&lt;:Number" href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool, Taylor1{T}}, Tuple{Bool, Taylor1{T}}, Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfacecrossing(g_old, g_now, eventorder::Int)</code></pre><p>Detect if the solution crossed a root of event function <code>g</code>. <code>g_old</code> represents the last-before-current value of event function <code>g</code>, and <code>g_now</code> represents the current one; these are <code>Tuple{Bool,Taylor1{T}}</code>s. <code>eventorder</code> is the order of the derivative of the event function <code>g</code> whose root we are trying to find. Returns <code>true</code> if the constant terms of <code>g_old[2]</code> and <code>g_now[2]</code> have different signs (i.e., if one is positive and the other one is negative). Otherwise, if <code>g_old[2]</code> and <code>g_now[2]</code> have the same sign or if the first component of either of them is <code>false</code>, then it returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/rootfinding.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Taylor1{U}, T, Any}} where {T&lt;:Real, U&lt;:Number}" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Taylor1{U}, T, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">taylorstep!(f, t, x, t0, order, abstol, params, tmpTaylor, arrTaylor, parse_eqs=true) -&gt; δt
taylorstep!(f!, t, x, dx, xaux, t0, order, abstol, params, tmpTaylor, arrTaylor, parse_eqs=true) -&gt; δt</code></pre><p>One-step Taylor integration for the one-dependent variable ODE <span>$\dot{x}=dx/dt=f(x, p, t)$</span> with initial conditions <span>$x(t_0)=x_0$</span>. Returns the time-step <code>δt</code> of the actual integration carried out (δt is positive).</p><p>Here, <code>f</code> is the function defining the RHS of the ODE (see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variable, <code>order</code> is the degree  used for the <code>Taylor1</code> polynomials during the integration <code>abstol</code> is the absolute tolerance used to determine the time step of the integration, and <code>params</code> are the parameters entering the ODE functions. For several variables, <code>dx</code> and <code>xaux</code>, both of the same type as <code>x</code>, are needed to save allocations. Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations). Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/161db118389e0b674f630ae5444367f401d781a5/src/integrator.jl#L201">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TaylorIntegration.__jetcoeffs!-Union{Tuple{U}, Tuple{Val{false}, Any, Any, Taylor1{U}, Any}} where U"><code>TaylorIntegration.__jetcoeffs!</code></a></li><li><a href="#TaylorIntegration._allocated_defs!-Tuple{Expr, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._allocated_defs!</code></a></li><li><a href="#TaylorIntegration._capture_fn_args_body!"><code>TaylorIntegration._capture_fn_args_body!</code></a></li><li><a href="#TaylorIntegration._defs_allocs!"><code>TaylorIntegration._defs_allocs!</code></a></li><li><a href="#TaylorIntegration._determine_parsing!-Tuple{Bool, Vararg{Any, 4}}"><code>TaylorIntegration._determine_parsing!</code></a></li><li><a href="#TaylorIntegration._extract_parts-Tuple{Expr}"><code>TaylorIntegration._extract_parts</code></a></li><li><a href="#TaylorIntegration._make_parsed_jetcoeffs-Tuple{Expr}"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a></li><li><a href="#TaylorIntegration._newfnbody!-Tuple{Any, Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._newfnbody!</code></a></li><li><a href="#TaylorIntegration._newhead-Tuple{Any, Any}"><code>TaylorIntegration._newhead</code></a></li><li><a href="#TaylorIntegration._parse_newfnbody!-Tuple{Expr, Expr, Expr, TaylorIntegration.BookKeeping, Bool}"><code>TaylorIntegration._parse_newfnbody!</code></a></li><li><a href="#TaylorIntegration._preamble_body-Tuple{Any, Any}"><code>TaylorIntegration._preamble_body</code></a></li><li><a href="#TaylorIntegration._recursionloop-Tuple{Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._recursionloop</code></a></li><li><a href="#TaylorIntegration._rename_indexedvars-Tuple{Any}"><code>TaylorIntegration._rename_indexedvars</code></a></li><li><a href="#TaylorIntegration._replace_expr!-Tuple{Expr, Expr, Expr, Int64, Any, Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration._replace_expr!</code></a></li><li><a href="#TaylorIntegration._replacecalls!-Tuple{TaylorIntegration.BookKeeping, Expr, Symbol}"><code>TaylorIntegration._replacecalls!</code></a></li><li><a href="#TaylorIntegration._returned_expr-Tuple{TaylorIntegration.BookKeeping}"><code>TaylorIntegration._returned_expr</code></a></li><li><a href="#TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration._second_stepsize</code></a></li><li><a href="#TaylorIntegration._split_arraydecl!-Tuple{TaylorIntegration.BookKeeping}"><code>TaylorIntegration._split_arraydecl!</code></a></li><li><a href="#TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U, T, Int64}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration._stepsize</code></a></li><li><a href="#TaylorIntegration.findroot!-NTuple{18, Any}"><code>TaylorIntegration.findroot!</code></a></li><li><a href="#TaylorIntegration.inbookkeeping-Tuple{Any, TaylorIntegration.BookKeeping}"><code>TaylorIntegration.inbookkeeping</code></a></li><li><a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, Taylor1{U}, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T}, AbstractArray{Taylor1{S}, 1}, AbstractArray{Taylor1{S}, 1}, Array{Taylor1{S}, 2}, Array{Taylor1{S}, 3}}} where {T&lt;:Real, S&lt;:Number}"><code>TaylorIntegration.lyap_jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.lyap_taylorinteg"><code>TaylorIntegration.lyap_taylorinteg</code></a></li><li><a href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, T, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 3}, Any, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.lyap_taylorstep!</code></a></li><li><a href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U, T, Int64, Int64}} where {U&lt;:Number, T&lt;:Real}"><code>TaylorIntegration.nrconvergencecriterion</code></a></li><li><a href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any}, Tuple{Any, Taylor1{T}, Array{Taylor1{U}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{TaylorN{Taylor1{U}}, 1}, Array{Taylor1{U}, 2}, Array{TaylorN{Taylor1{U}}, 1}, Any, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.stabilitymatrix!</code></a></li><li><a href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U}, T}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.stepsize</code></a></li><li><a href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool, Taylor1{T}}, Tuple{Bool, Taylor1{T}}, Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a></li><li><a href="#TaylorIntegration.taylorinteg"><code>TaylorIntegration.taylorinteg</code></a></li><li><a href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any, Taylor1{T}, Taylor1{U}, T, Any}} where {T&lt;:Real, U&lt;:Number}"><code>TaylorIntegration.taylorstep!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../taylorize/">« Optimizing: <code>@taylorize</code></a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 3 April 2024 10:27">Wednesday 3 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
