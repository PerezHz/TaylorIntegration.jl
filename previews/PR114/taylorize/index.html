<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing: @taylorize · TaylorIntegration.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TaylorIntegration.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../taylor_method/">Taylor&#39;s method</a></li><li><a class="tocitem" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="tocitem" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../simple_example/">Infinity in finite time</a></li><li><a class="tocitem" href="../kepler/">The Kepler problem</a></li><li><a class="tocitem" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="tocitem" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="tocitem" href="../root_finding/">Poincaré maps</a></li><li><a class="tocitem" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li class="is-active"><a class="tocitem" href>Optimizing: <code>@taylorize</code></a><ul class="internal"><li><a class="tocitem" href="#idea"><span>Some context and the idea</span></a></li><li><a class="tocitem" href="#An-example"><span>An example</span></a></li><li><a class="tocitem" href="#Limitations-and-some-advices"><span>Limitations and some advices</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimizing: <code>@taylorize</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimizing: <code>@taylorize</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/master/docs/src/taylorize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="taylorize"><a class="docs-heading-anchor" href="#taylorize">Optimizing: <code>@taylorize</code></a><a id="taylorize-1"></a><a class="docs-heading-anchor-permalink" href="#taylorize" title="Permalink"></a></h1><p>Here, we describe the use of the macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, which parses the functions containing the ODEs to be integrated, allowing to speed up <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is still in an experimental phase; be cautious of the resulting integration, which has to be tested carefully.</p></div></div><h2 id="idea"><a class="docs-heading-anchor" href="#idea">Some context and the idea</a><a id="idea-1"></a><a class="docs-heading-anchor-permalink" href="#idea" title="Permalink"></a></h2><p>The way in which <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> works by default is by calling repeatedly the function where the ODEs of the problem are defined, in order to compute the recurrence relations that are used to construct the Taylor expansion of the solution. This is done for each order of the series in <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},Any}} where N where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a>. These computations are not optimized: they waste memory due to allocations of some temporary arrays, and perform some operations whose result has been previously computed.</p><p>Here we describe one way to optimize this: The idea is to replace the default method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},Any}} where N where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> by another (with the same name) which is called by dispatch, that in principle performs better. The new method is constructed specifically for the actual function defining the equations of motion by parsing its expression; the new function performs in principle <em>exactly</em> the same operations, but avoids the extra allocations and the repetition of some operations.</p><h2 id="An-example"><a class="docs-heading-anchor" href="#An-example">An example</a><a id="An-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-example" title="Permalink"></a></h2><p>In order to explain how the macro works, we shall use as an example the <a href="../pendulum/#pendulum">mathematical pendulum</a>. First, we carry out the integration using the default method, as described <a href="../pendulum/#pendulum">before</a>.</p><pre><code class="language-julia">using TaylorIntegration

function pendulum!(dx, x, p, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

# Initial time (t0), final time (tf) and initial condition (q0)
t0 = 0.0
tf = 100.0
q0 = [1.3, 0.0]

# The actual integration
t1, x1 = taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500); # warm-up run
e1 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500);
e1</code></pre><pre class="documenter-example-output">0.012266731</pre><p>We note that the initial number of methods defined for <code>TaylorIntegration.jetcoeffs!</code> is 2.</p><pre><code class="language-julia">length(methods(TaylorIntegration.jetcoeffs!)) == 2 # initial value</code></pre><pre class="documenter-example-output">true</pre><p>Using <code>@taylorize</code> will increase this number by creating a new method.</p><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is intended to be used in front of the function that implements the equations of motion. The macro does the following: it first parses the actual function as it is, so the integration can be computed using <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> as above, by explicitly using the keyword argument <code>parse_eqs=false</code>. It then creates and evaluates a new method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},Any}} where N where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a>, which is the specialized method (through <code>Val</code>) on the specific function passed to the macro.</p><pre><code class="language-julia">@taylorize function pendulum!(dx, x, p, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

println(methods(pendulum!))</code></pre><pre class="documenter-example-output"># 1 method for generic function &quot;pendulum!&quot;:
[1] pendulum!(dx, x, p, t) in Main.ex-taylorize</pre><pre><code class="language-julia">println(methods(TaylorIntegration.jetcoeffs!))</code></pre><pre class="documenter-example-output"># 3 methods for generic function &quot;jetcoeffs!&quot;:
[1] jetcoeffs!(eqsdiff::Function, t::Taylor1{T}, x::Taylor1{U}, params) where {T&lt;:Real, U&lt;:Number} in TaylorIntegration at /home/travis/build/PerezHz/TaylorIntegration.jl/src/explicitode.jl:23
[2] jetcoeffs!(eqsdiff!::Function, t::Taylor1{T}, x::AbstractArray{Taylor1{U},N}, dx::AbstractArray{Taylor1{U},N}, xaux::AbstractArray{Taylor1{U},N}, params) where {T&lt;:Real, U&lt;:Number, N} in TaylorIntegration at /home/travis/build/PerezHz/TaylorIntegration.jl/src/explicitode.jl:63
[3] jetcoeffs!(::Val{Main.ex-taylorize.pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S},_N}, dx::AbstractArray{Taylor1{_S},_N}, p) where {_T&lt;:Real, _S&lt;:Number, _N} in Main.ex-taylorize</pre><p>We see that there is only one method of <code>pendulum!</code>, and there is a new method of <code>TaylorIntegration.jetcoeffs!</code>, whose signature appears in this documentation as <code>Val{Main.ex-taylorize.pendulum!}</code>; it is an specialized version for the function <code>pendulum!</code> (with some extra information about the module where the function was created). This method is selected internally if it exists (default), exploiting dispatch, when calling <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> or <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a>; to integrate using the hard-coded method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},AbstractArray{Taylor1{U},N},Any}} where N where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> of the integration above, the keyword argument <code>parse_eqs</code> has to be set to <code>false</code>.</p><p>Now we carry out the integration using the specialized method; note that we use the same instruction as above.</p><pre><code class="language-julia">t2, x2 = taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500); # warm-up run
e2 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500);
e2</code></pre><pre class="documenter-example-output">0.003071842</pre><p>We note the difference in the performance:</p><pre><code class="language-julia">e1/e2</code></pre><pre class="documenter-example-output">3.9932818810342456</pre><p>We can check that both integrations yield the same results.</p><pre><code class="language-julia">t1 == t2 &amp;&amp; x1 == x2</code></pre><pre class="documenter-example-output">true</pre><p>As stated above, in order to allow to opt-out from using the specialized method created by <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> recognize the keyword argument <code>parse_eqs</code>; setting it to <code>false</code> imposes using the standard method.</p><pre><code class="language-julia">taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500, parse_eqs=false); # warm-up run

e3 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=1500, parse_eqs=false);

e1/e3</code></pre><pre class="documenter-example-output">1.1349310611639205</pre><p>We now illustrate the possibility of exploiting the macro when using <code>TaylorIntegration.jl</code> from <code>DifferentialEquations.jl</code>.</p><pre><code class="language-julia">using DiffEqBase

prob = ODEProblem(pendulum!, q0, (t0, tf), nothing) # no parameters
solT = solve(prob, TaylorMethod(25), abstol=1e-20, parse_eqs=true); # warm-up run
e4 = @elapsed solve(prob, TaylorMethod(25), abstol=1e-20, parse_eqs=true);

e1/e4</code></pre><pre class="documenter-example-output">1.1857810835978047</pre><p>Note that there is a marginal cost of using <code>solve</code> in comparison with <code>taylorinteg</code>.</p><p>The speed-up obtained comes from the design of the new (specialized) method of <code>TaylorIntegration.jetcoeffs!</code> as described <a href="#idea">above</a>: it avoids some allocations and some repeated computations. This is achieved by knowing the specific AST of the function of the ODEs integrated, which is walked through and <em>translated</em> into the actual implementation, where some required auxiliary arrays are created and the low-level functions defined in <code>TaylorSeries.jl</code> are used. For this, we heavily rely on <a href="https://github.com/dfdx/Espresso.jl"><code>Espresso.jl</code></a> and some metaprogramming; we thank Andrei Zhabinski for his help and comments.</p><p>The new <code>jetcoeffs!</code> method can be inspected by constructing the expression corresponding to the function, and using <a href="../api/#TaylorIntegration._make_parsed_jetcoeffs"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a>:</p><pre><code class="language-julia">ex = :(function pendulum!(dx, x, p, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end)

new_ex = TaylorIntegration._make_parsed_jetcoeffs(ex)</code></pre><pre class="documenter-example-output">:(function TaylorIntegration.jetcoeffs!(::Val{pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S}, _N}, dx::AbstractArray{Taylor1{_S}, _N}, p) where {_T &lt;: Real, _S &lt;: Number, _N}
      order = t.order
      dx[1] = Taylor1(identity(constant_term(x[2])), order)
      tmp353 = Taylor1(sin(constant_term(x[1])), order)
      tmp355 = Taylor1(cos(constant_term(x[1])), order)
      dx[2] = Taylor1(-(constant_term(tmp353)), order)
      for __idx = eachindex(x)
          (x[__idx]).coeffs[2] = (dx[__idx]).coeffs[1]
      end
      for ord = 1:order - 1
          ordnext = ord + 1
          TaylorSeries.identity!(dx[1], x[2], ord)
          TaylorSeries.sincos!(tmp353, tmp355, x[1], ord)
          TaylorSeries.subst!(dx[2], tmp353, ord)
          for __idx = eachindex(x)
              (x[__idx]).coeffs[ordnext + 1] = (dx[__idx]).coeffs[ordnext] / ordnext
          end
      end
      return nothing
  end)</pre><p>This function has a similar structure as the hard-coded method of <code>TaylorIntegration.jetcoeffs!</code>, but uses low-level functions in <code>TaylorSeries</code> (e.g., <code>sincos!</code> above) and explicitly allocates the needed temporary arrays. More complex functions become easily very difficult to read. Note that, if necessary, one can further optimize <code>new_ex</code> manually.</p><h2 id="Limitations-and-some-advices"><a class="docs-heading-anchor" href="#Limitations-and-some-advices">Limitations and some advices</a><a id="Limitations-and-some-advices-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations-and-some-advices" title="Permalink"></a></h2><p>The construction of the internal function obtained by using <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is somewhat complicated and limited. Here we list some limitations and advices.</p><ul><li><p>It is useful to have expressions which involve two arguments at most, which imposes the proper use of parenthesis: For example, <code>res = a+b+c</code> should be written as <code>res = (a+b)+c</code>.</p></li><li><p>Updating operators such as <code>+=</code>, <code>*=</code>, etc., are not supported. For example, the expression <code>x += y</code> is not recognized by <code>@taylorize</code>. Likewise, expressions such as <code>x = x+y</code> are not supported by <code>@taylorize</code> and should be substituted by equivalent expressions; e.g. <code>z = x+y; x = z</code>.</p></li><li><p>The macro allows to use array declarations through <code>Array</code>, but other ways (e.g. <code>similar</code>) are not yet implemented.</p></li><li><p>Avoid using variables prefixed by an underscore, in particular <code>_T</code>, <code>_S</code> and <code>_N</code>; using them may lead to name collisions with some internal variables.</p></li><li><p>Broadcasting is not recognized by <code>@taylorize</code>.</p></li><li><p>The macro may be used in combination with the <a href="../common/#diffeqinterface">common interface with <code>DifferentialEquations.jl</code></a>, for functions using the <code>(du, u, p, t)</code> in-place form, as we showed above. Other extensions allowed by <code>DifferentialEquations</code> may not be able to exploit it.</p></li><li><p><code>if-else</code> blocks are recognized in its long form, but short-circuit conditional operators (<code>&amp;&amp;</code> and <code>||</code>) are not.</p></li><li><p>Expressions which correspond to function calls (so the <code>head</code> field is <code>:call</code>) which are not recognized by the parser are simply copied. The heuristics used, specially for vectors, may not work for all cases.</p></li><li><p>Use <code>local</code> for internal parameters (simple constant values); this improves performance. Do not use it if the variable is Taylor expanded.</p></li><li><p><code>@taylorize</code> supports multi-threading via <code>Threads.@threads</code>. <strong>WARNING</strong>: this feature is experimental. Since thread-safety depends on the definition of each ODE, we cannot guarantee the resulting code to be thread-safe in advance. The user should check the resulting code to ensure that it is indeed thread-safe. For more information about multi-threading, the reader is referred to the <a href="https://docs.julialang.org/en/v1/manual/parallel-computing#man-multithreading-1">Julia documentation</a>.</p></li></ul><p>It is recommended to skim <code>test/taylorize.jl</code>, which implements different cases.</p><p>Please report any problems you may encounter.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../common/">« Interoperability with <code>DifferentialEquations.jl</code></a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 17 November 2020 06:54">Tuesday 17 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
