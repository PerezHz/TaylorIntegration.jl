<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing: @taylorize · TaylorIntegration.jl</title><meta name="title" content="Optimizing: @taylorize · TaylorIntegration.jl"/><meta property="og:title" content="Optimizing: @taylorize · TaylorIntegration.jl"/><meta property="twitter:title" content="Optimizing: @taylorize · TaylorIntegration.jl"/><meta name="description" content="Documentation for TaylorIntegration.jl."/><meta property="og:description" content="Documentation for TaylorIntegration.jl."/><meta property="twitter:description" content="Documentation for TaylorIntegration.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TaylorIntegration.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../taylor_method/">Taylor&#39;s method</a></li><li><a class="tocitem" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="tocitem" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../simple_example/">Infinity in finite time</a></li><li><a class="tocitem" href="../kepler/">The Kepler problem</a></li><li><a class="tocitem" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="tocitem" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="tocitem" href="../root_finding/">Poincaré maps</a></li><li><a class="tocitem" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li class="is-active"><a class="tocitem" href>Optimizing: <code>@taylorize</code></a><ul class="internal"><li><a class="tocitem" href="#idea"><span>Some context and the idea</span></a></li><li><a class="tocitem" href="#An-example"><span>An example</span></a></li><li><a class="tocitem" href="#Limitations-and-some-advice"><span>Limitations and some advice</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimizing: <code>@taylorize</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimizing: <code>@taylorize</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PerezHz/TaylorIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/main/docs/src/taylorize.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="taylorize"><a class="docs-heading-anchor" href="#taylorize">Optimizing: <code>@taylorize</code></a><a id="taylorize-1"></a><a class="docs-heading-anchor-permalink" href="#taylorize" title="Permalink"></a></h1><p>Here, we describe the use of the macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, which parses the functions containing the ODEs to be integrated, allowing <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> to be sped up.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is still in an experimental state; be cautious of the resulting integration, which has to be tested carefully.</p></div></div><h2 id="idea"><a class="docs-heading-anchor" href="#idea">Some context and the idea</a><a id="idea-1"></a><a class="docs-heading-anchor-permalink" href="#idea" title="Permalink"></a></h2><p>The way in which <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> works by default is repeatedly calling the function where the ODEs of the problem are defined, in order to compute the recurrence relations that are used to construct the Taylor expansion of the solution. This is done for each order of the series in <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a>. These computations are not optimized: they waste memory due to repeated allocations of some temporary arrays, and perform some operations whose result has already been previously computed.</p><p>Here we describe one way to optimize this: The idea is to replace the default method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a> by another method (same function name) which is called by dispatch, and that in principle performs better. The new method is constructed specifically for the function defining the equations of motion by parsing its expression. This new method performs in principle <em>exactly</em> the same operations, but avoids repeating some operations and the extra allocations. To achieve the latter, the macro also creates an <em>internal</em> function <code>TaylorIntegration._allocate_jetcoeffs!</code>, which allocates all temporary <code>Taylor1</code> objects as well as the declared <code>Array{Taylor1,N}</code>s, which are stored in a <a href="../api/#TaylorIntegration.RetAlloc"><code>TaylorIntegration.RetAlloc</code></a> struct for efficiency, and include arrays (of <code>Taylor1{T}</code> objects) with up-to-three indices.</p><h2 id="An-example"><a class="docs-heading-anchor" href="#An-example">An example</a><a id="An-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-example" title="Permalink"></a></h2><p>In order to explain how the macro works, we shall use as an example the <a href="../pendulum/#pendulum">mathematical pendulum</a>. First, we carry out the integration using the default method, as described <a href="../pendulum/#pendulum">before</a>.</p><pre><code class="language-julia hljs">using TaylorIntegration

function pendulumNP!(dx, x, p, t) # `pendulum!` ODEs, not parsed
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

# Initial time (t0), final time (tf) and initial condition (q0)
t0 = 0.0
tf = 10000.0
q0 = [1.3, 0.0]

# The actual integration
t1, x1 = taylorinteg(pendulumNP!, q0, t0, tf, 25, 1e-20, maxsteps=50000); # warm-up run
e1 = @elapsed taylorinteg(pendulumNP!, q0, t0, tf, 25, 1e-20, maxsteps=50000);
all1 = @allocated taylorinteg(pendulumNP!, q0, t0, tf, 25, 1e-20, maxsteps=50000);
e1, all1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.903723532, 761690960)</code></pre><p>The initial number of methods defined for <code>TaylorIntegration.jetcoeffs!</code> is 2; yet, since <code>@taylorize</code> was used in <a href="../common/#diffeqinterface">an example previously</a>, the current number of methods is 3, as explained below.</p><pre><code class="language-julia hljs">println(methods(TaylorIntegration.jetcoeffs!)) # default methods</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"># 3 methods for generic function &quot;jetcoeffs!&quot; from TaylorIntegration:
 [1] jetcoeffs!(::Val{Main.__atexample__named__common.pcr3bp!}, t::Taylor1{_T}, q::AbstractArray{Taylor1{_S}, _N}, dq::AbstractArray{Taylor1{_S}, _N}, param, __ralloc::TaylorIntegration.RetAlloc{Taylor1{_S}}) where {_T&lt;:Real, _S&lt;:Number, _N}
     @ Main.__atexample__named__common none:0
 [2] jetcoeffs!(eqsdiff!::Function, t::Taylor1{T}, x::AbstractArray{Taylor1{U}, N}, dx::AbstractArray{Taylor1{U}, N}, xaux::AbstractArray{Taylor1{U}, N}, params) where {T&lt;:Real, U&lt;:Number, N}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:63
 [3] jetcoeffs!(eqsdiff::Function, t::Taylor1{T}, x::Taylor1{U}, params) where {T&lt;:Real, U&lt;:Number}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:23</code></pre><p>Similarly, the number of methods for <code>TaylorIntegration._allocate_jetcoeffs!</code> originally is 2, and for the same reasons it is currently 3.</p><pre><code class="language-julia hljs">println(methods(TaylorIntegration._allocate_jetcoeffs!)) # default methods</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"># 3 methods for generic function &quot;_allocate_jetcoeffs!&quot; from TaylorIntegration:
 [1] _allocate_jetcoeffs!(::Val{Main.__atexample__named__common.pcr3bp!}, t::Taylor1{_T}, q::AbstractArray{Taylor1{_S}, _N}, dq::AbstractArray{Taylor1{_S}, _N}, param) where {_T&lt;:Real, _S&lt;:Number, _N}
     @ Main.__atexample__named__common none:0
 [2] _allocate_jetcoeffs!(::Taylor1{T}, x::AbstractArray{Taylor1{S}, N}, ::AbstractArray{Taylor1{S}, N}, params) where {T, S, N}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:112
 [3] _allocate_jetcoeffs!(::Taylor1{T}, x::Taylor1{S}, params) where {T, S}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:111</code></pre><p>Using <code>@taylorize</code> will increase this number by creating a new method for these functions.</p><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is intended to be used in front of the function that implements the equations of motion. The macro does the following: it first parses the function as it is, so the integration can still be computed using <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> as above, by explicitly using the keyword argument <code>parse_eqs=false</code>; this also declares the function of the ODEs, whose name is used for parsing. It then creates and evaluates a new method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a>, which is the specialized method (through <code>Val</code>) on the specific function passed to the macro as well as a specialized <code>TaylorIntegration._allocate_jetcoeffs!</code>.</p><pre><code class="language-julia hljs">@taylorize function pendulum!(dx, x, p, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

println(methods(pendulum!))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"># 1 method for generic function &quot;pendulum!&quot; from Main:
 [1] pendulum!(dx, x, p, t)
     @ none:0</code></pre><pre><code class="language-julia hljs">println(methods(TaylorIntegration.jetcoeffs!)) # result should be 4</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"># 4 methods for generic function &quot;jetcoeffs!&quot; from TaylorIntegration:
 [1] jetcoeffs!(::Val{Main.pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S}, _N}, dx::AbstractArray{Taylor1{_S}, _N}, p, __ralloc::TaylorIntegration.RetAlloc{Taylor1{_S}}) where {_T&lt;:Real, _S&lt;:Number, _N}
     @ Main none:0
 [2] jetcoeffs!(::Val{Main.__atexample__named__common.pcr3bp!}, t::Taylor1{_T}, q::AbstractArray{Taylor1{_S}, _N}, dq::AbstractArray{Taylor1{_S}, _N}, param, __ralloc::TaylorIntegration.RetAlloc{Taylor1{_S}}) where {_T&lt;:Real, _S&lt;:Number, _N}
     @ Main.__atexample__named__common none:0
 [3] jetcoeffs!(eqsdiff!::Function, t::Taylor1{T}, x::AbstractArray{Taylor1{U}, N}, dx::AbstractArray{Taylor1{U}, N}, xaux::AbstractArray{Taylor1{U}, N}, params) where {T&lt;:Real, U&lt;:Number, N}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:63
 [4] jetcoeffs!(eqsdiff::Function, t::Taylor1{T}, x::Taylor1{U}, params) where {T&lt;:Real, U&lt;:Number}
     @ ~/work/TaylorIntegration.jl/TaylorIntegration.jl/src/integrator.jl:23</code></pre><p>We see that there is only one method of <code>pendulum!</code>, and there is a <em>new</em> method (four in total) of <code>TaylorIntegration.jetcoeffs!</code>, whose signature appears in this documentation as <code>Val{Main.pendulum!}</code>. It is a specialized version for the function <code>pendulum!</code> (with some extra information about the module where the function was created). This method is selected internally if it exists (default), exploiting dispatch, when calling <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> or <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a>. In order to integrate using the hard-coded standard (default) method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{N}, Tuple{U}, Tuple{T}, Tuple{Function, Taylor1{T}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, AbstractArray{Taylor1{U}, N}, Any}} where {T&lt;:Real, U&lt;:Number, N}"><code>TaylorIntegration.jetcoeffs!</code></a> of the integration above, the keyword argument <code>parse_eqs</code> has to be set to <code>false</code>. Similarly, one can check that there exists a new method of <code>TaylorIntegration._allocate_jetcoeffs!</code>.</p><p>Now we carry out the integration using the specialized method; note that we use the same instruction as above; the default value for the keyword argument <code>parse_eqs</code> is <code>true</code>, so we may omit it.</p><pre><code class="language-julia hljs">t2, x2 = taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000); # warm-up run
e2 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000);
all2 = @allocated taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000);
e2, all2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.055468138, 1210896)</code></pre><p>We note the difference in the performance and allocations:</p><pre><code class="language-julia hljs">e1/e2, all1/all2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(16.292660337723973, 629.0308663997569)</code></pre><p>We can check that both integrations yield the same results.</p><pre><code class="language-julia hljs">t1 == t2 &amp;&amp; x1 == x2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>As stated above, in order to allow opting out of using the specialized method created by <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> recognize the keyword argument <code>parse_eqs</code>; setting it to <code>false</code> causes the standard method to be used.</p><pre><code class="language-julia hljs">taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000, parse_eqs=false); # warm-up run

e3 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000, parse_eqs=false);
all3 = @allocated taylorinteg(pendulum!, q0, t0, tf, 25, 1e-20, maxsteps=50000, parse_eqs=false);
e1/e3, all1/all3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.985248474688758, 1.0000025837317077)</code></pre><p>We now illustrate the possibility of exploiting the macro when using <code>TaylorIntegration.jl</code> from <code>DifferentialEquations.jl</code>.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq

prob = ODEProblem(pendulum!, q0, (t0, tf), nothing) # no parameters
solT = solve(prob, TaylorMethod(25), abstol=1e-20, parse_eqs=true); # warm-up run
e4 = @elapsed solve(prob, TaylorMethod(25), abstol=1e-20, parse_eqs=true);

e1/e4</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14.212819676711042</code></pre><p>Note that there is an additional cost to using <code>solve</code> in comparison with <code>taylorinteg</code>, but still <code>@taylorize</code> yields improved running times.</p><p>The speed-up obtained comes from the design of the new (specialized) method of <code>TaylorIntegration.jetcoeffs!</code> as described <a href="#idea">above</a>: it avoids some allocations and some repeated computations. This is achieved by knowing the specific AST of the function of the ODEs integrated, which is walked through and <em>translated</em> into the actual implementation, where some required auxiliary arrays are created and reused, and the low-level functions defined in <code>TaylorSeries.jl</code> are used. For this, we heavily rely on <a href="https://github.com/dfdx/Espresso.jl"><code>Espresso.jl</code></a> and some metaprogramming; we thank Andrei Zhabinski for his help and comments.</p><p>The new <code>TaylorIntegration.jetcoeffs!</code> and <code>TaylorIntegration._allocate_jetcoeffs!</code> methods can be inspected by constructing the expression corresponding to the function, and using <a href="../api/#TaylorIntegration._make_parsed_jetcoeffs-Tuple{Expr}"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a>:</p><pre><code class="language-julia hljs">ex = :(function pendulum!(dx, x, p, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end)

new_ex1, new_ex2 = TaylorIntegration._make_parsed_jetcoeffs(ex)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:(function TaylorIntegration.jetcoeffs!(::Val{pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S}, _N}, dx::AbstractArray{Taylor1{_S}, _N}, p, __ralloc::TaylorIntegration.RetAlloc{Taylor1{_S}}) where {_T &lt;: Real, _S &lt;: Number, _N}
      order = t.order
      tmp2356 = __ralloc.v0[1]
      tmp2358 = __ralloc.v0[2]
      TaylorSeries.zero!(dx[1])
      (dx[1]).coeffs[1] = identity(constant_term(x[2]))
      TaylorSeries.zero!(tmp2356)
      tmp2356.coeffs[1] = sin(constant_term(x[1]))
      TaylorSeries.zero!(tmp2358)
      tmp2358.coeffs[1] = cos(constant_term(x[1]))
      TaylorSeries.zero!(dx[2])
      (dx[2]).coeffs[1] = -(constant_term(tmp2356))
      for __idx = eachindex(x)
          (x[__idx]).coeffs[2] = (dx[__idx]).coeffs[1]
      end
      for ord = 1:order - 1
          ordnext = ord + 1
          TaylorSeries.identity!(dx[1], x[2], ord)
          TaylorSeries.sincos!(tmp2356, tmp2358, x[1], ord)
          TaylorSeries.subst!(dx[2], tmp2356, ord)
          for __idx = eachindex(x)
              (x[__idx]).coeffs[ordnext + 1] = (dx[__idx]).coeffs[ordnext] / ordnext
          end
      end
      return nothing
  end), :(function TaylorIntegration._allocate_jetcoeffs!(::Val{pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S}, _N}, dx::AbstractArray{Taylor1{_S}, _N}, p) where {_T &lt;: Real, _S &lt;: Number, _N}
      order = t.order
      dx[1] = Taylor1(identity(constant_term(x[2])), order)
      tmp2356 = Taylor1(sin(constant_term(x[1])), order)
      tmp2358 = Taylor1(cos(constant_term(x[1])), order)
      dx[2] = Taylor1(-(constant_term(tmp2356)), order)
      return TaylorIntegration.RetAlloc{Taylor1{_S}}([tmp2356, tmp2358], [Array{Taylor1{_S}, 1}(undef, 0)], [Array{Taylor1{_S}, 2}(undef, 0, 0)], [Array{Taylor1{_S}, 3}(undef, 0, 0, 0)], [Array{Taylor1{_S}, 4}(undef, 0, 0, 0, 0)])
  end))</code></pre><p>The first function has a similar structure as the hard-coded method of <code>TaylorIntegration.jetcoeffs!</code>, but uses low-level functions in <code>TaylorSeries</code> (e.g., <code>sincos!</code> above). Temporary <code>Taylor1</code> objects as well as declared arrays are allocated once by <code>TaylorIntegration._allocate_jetcoeffs!</code>. More complex functions quickly become very difficult to read. Note that, if necessary, one can further optimize <code>new_ex</code> manually.</p><h2 id="Limitations-and-some-advice"><a class="docs-heading-anchor" href="#Limitations-and-some-advice">Limitations and some advice</a><a id="Limitations-and-some-advice-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations-and-some-advice" title="Permalink"></a></h2><p>The construction of the internal function obtained by using <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is somewhat complicated and limited. Here we list some limitations and provide some advice.</p><ul><li><p>Expressions must involve two arguments at most, which requires using parentheses appropriately: For example, <code>res = a+b+c</code> should be written as <code>res = (a+b)+c</code>.  This may lead to more parentheses used in compound expressions than would be typical outside of the <code>@taylorize</code> context. It also means the sequence of operations will be explicit for a compound expression rather than implicit.</p></li><li><p>Updating operators such as <code>+=</code>, <code>*=</code>, etc., are not supported. For example, the expression <code>x += y</code> is not recognized by <code>@taylorize</code>. Likewise, expressions such as <code>x = x+y</code> are not supported by <code>@taylorize</code> and should be replaced by equivalent expressions in which variables appear only on one side of the assignment; e.g. <code>z = x+y; x = z</code>. The introduction of such temporary variables <code>z</code> is left to the user.</p></li><li><p>The macro allows the use of array declarations through <code>Array</code> or <code>Vector</code>, but other ways (e.g. <code>similar</code>) are not yet implemented. Note that certain temporary arrays may be introduced to avoid re-computating certain expressions; only up-to-three indices expressions are currently handled.</p></li><li><p>Avoid using variables prefixed by an underscore, in particular <code>_T</code>, <code>_S</code>, <code>_N</code> and <code>__idx</code>, as well as <code>ord</code>; using them may lead to name collisions with some internal variables used in the constructed expressions.</p></li><li><p>Broadcasting is not recognized by <code>@taylorize</code>.</p></li><li><p>The macro may be used in combination with the <a href="../common/#diffeqinterface">common interface with <code>DifferentialEquations.jl</code></a>, for functions using the <code>(du, u, p, t)</code> in-place form, as we showed above. Other extensions allowed by <code>DifferentialEquations</code> may not be able to exploit it.</p></li><li><p><code>if-else</code> blocks are recognized in their long form, but short-circuit conditional operators (<code>&amp;&amp;</code> and <code>||</code>) are not.  When comparing to a Taylor expansion, use operators such as <code>iszero</code> for <code>if-else</code> tests rather than comparing against numeric literals.</p></li><li><p>Input and output lengths should be determined at the time of <code>@taylorize</code> application (parse time), not at runtime.  Avoid using the length of the input as an implicit indicator of whether to write all elements of the output.  If conditional output of auxiliary equations is desired use explicit methods, such as through parameters or by setting auxiliary vector elements to zero, and assigning unwanted auxiliary outputs zero.</p></li><li><p>Expressions which correspond to function calls (so the <code>head</code> field is <code>:call</code>) which are not recognized by the parser are simply copied. The heuristics used, especially for vectors, may not work for all cases.</p></li><li><p>Use <code>local</code> for internal parameters, e.g., simple constant values; this improves performance. Do not use it if the variable is needed to be Taylor expanded during the integration step.</p></li><li><p>To examine the code generated for <code>jetcoeffs!</code> and <code>_allocate_jetcoeffs!</code> for a specific ODE function, follow the pendulum example above; create an expression by wrapping the ODE function (without <code>@taylorize</code> prefix) in a <code>:()</code>-block, and supply the expression to <code>TaylorIntegration._make_parsed_jetcoeffs</code>.  This can help in debugging issues with either function generated by <code>@taylorize</code>.</p></li><li><p><code>@taylorize</code> supports multi-threading via <code>Threads.@threads</code>. <strong>WARNING</strong>: this feature is experimental. Since thread-safety depends on the definition of each ODE, we cannot guarantee the resulting code to be thread-safe in advance. The user should check the resulting code to ensure that it is indeed thread-safe. For more information about multi-threading, the reader is referred to the <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#man-multithreading">Julia documentation</a>.</p></li></ul><p>We recommend to skim <code>test/taylorize.jl</code>, which implements different cases and highlights examples where the macro does not work, and how to solve the problem; read the information that is in the comments.</p><p>Please report any problems you may encounter.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../common/">« Interoperability with <code>DifferentialEquations.jl</code></a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 5 April 2024 09:17">Friday 5 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
