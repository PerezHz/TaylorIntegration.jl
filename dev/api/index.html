<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorIntegration.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorIntegration.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Background</span><ul><li><a class="toctext" href="../taylor_method/">ODE integration using Taylor&#39;s method</a></li><li><a class="toctext" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="toctext" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../simple_example/">Infinity in finite time</a></li><li><a class="toctext" href="../kepler/">The Kepler problem</a></li><li><a class="toctext" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="toctext" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="toctext" href="../root_finding/">Poincaré maps</a></li><li><a class="toctext" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li><a class="toctext" href="../taylorize/">Optimizing: <code>@taylorize</code></a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Exported-functions-1">Exported functions</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><hr/><h2><a class="nav-anchor" id="Exported-functions-1" href="#Exported-functions-1">Exported functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorinteg" href="#TaylorIntegration.taylorinteg"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">taylorinteg(f, x0, t0, tmax, order, abstol; kwargs... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(t,x)$</span>, with initial condition specified by <code>x0</code> at time <code>t0</code>. The initial condition <code>x0</code> may be of type <code>T&lt;:Number</code> or <code>Vector{T}</code>, with <code>T</code> including <code>TaylorN{T}</code>; the latter case is of interest for jet transport applications.</p><p>It returns a vector with the values of time (independent variable), and a vector with the computed values of the dependent variable(s). The integration stops when time is larger than <code>tmax</code>, in which case the last returned value(s) correspond to that time, or when the number of saved steps is larger than <code>maxsteps</code>.</p><p>The integration method uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>The current keyword argument are:</p><ul><li><code>maxsteps=500</code>: maximum number of integration steps.</li><li><code>parse_eqs=true</code>: usie the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li></ul><p><strong>Examples</strong></p><ul><li>One dependent variable: The function <code>f</code> defines the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    f(t, x) = x^2

    tv, xv = taylorinteg(f, 3, 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><ul><li>Many (two or more) dependent variable: The function <code>f!</code> defines   the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    function f!(t, x, dx)
        for i in eachindex(x)
            dx[i] = x[i]^2
        end
    end

    tv, xv = taylorinteg(f!, [3.0,3.0], 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><p>Note that <code>f!</code> updates (mutates) the pre-allocated vector <code>dx</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L228">source</a><div><pre><code class="language-none">taylorinteg(f, x0, trange, order, abstol; keyword... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(t,x)$</span> with initial condition specified by <code>x0::{T&lt;:Number}</code> or <code>x0::Vector{T}</code> at time <code>t0</code>. It returns a vector (of type <code>typeof(x0)</code>) with the computed values of the dependent variable(s), evaluated <em>only</em> at the times specified by the range <code>trange</code>. The integration stops at <code>tmax=trange[end]</code>, in which case the last returned values are <code>t_max</code>, <code>x(t_max)</code>, or when the number of computed time steps is larger than <code>maxsteps</code>.</p><p>The integration method uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>The current keyword argument are:</p><ul><li><code>maxsteps=500</code>: maximum number of integration steps</li><li><code>parse_eqs=true</code>: usie the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li></ul><p><strong>Examples</strong></p><ul><li>One dependent variable: The function <code>f</code> defines the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    f(t, x) = x^2

    xv = taylorinteg(f, 3.0, 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><ul><li>Many (two or more) dependent variable: The function f! defines the   equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    function f!(t, x, dx)
        for i in eachindex(x)
            dx[i] = x[i]^2
        end
    end

    xv = taylorinteg(f!, [3.0, 3.0], 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><p>Note that f! updates (mutates) the pre-allocated vector dx.</p><ul><li>Jet transport for the simple pendulum.</li></ul><pre><code class="language-julia">    using TaylorIntegration # TaylorSeries is reexported automatically

    function pendulum!(t, x, dx) #the simple pendulum ODE
        dx[1] = x[2]
        dx[2] = -sin(x[1])
    end

    p = set_variables(&quot;ξ&quot;, numvars=2, order=5) #TaylorN set-up, order 5
    q0 = [1.3, 0.0]    # initial conditions
    q0TN = q0 + p      # parametrization of a neighbourhood around q0
    tr = 0.0:0.125:6pi

    @time xv = taylorinteg(pendulum!, q0TN, tr, 28, 1e-20, maxsteps=100);</code></pre><p>Note that the initial conditions <code>q0TN</code> are of type <code>TaylorN{Float64}</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L411">source</a><div><div><pre><code class="language-none">taylorinteg(f, g, x0, t0, tmax, order, abstol; kwargs... )</code></pre><p>Root-finding method of <code>taylorinteg</code>. Given a function <code>g(t, x, dx)</code>, called the event function, <code>taylorinteg</code> checks for the occurrence of a root of <code>g</code> evaluated at the solution; that is, it checks for the occurrence of an event or condition specified by <code>g=0</code>. Then, <code>taylorinteg</code> attempts to find that root (or event, or crossing) by performing a Newton-Raphson process. When called with the <code>eventorder=n</code> keyword argument, <code>taylorinteg</code> searches for the roots of the <code>n</code>-th derivative of <code>g</code>, which is computed via automatic differentiation.</p><p><code>maxsteps</code> is the maximum number of allowed time steps; <code>eventorder</code> is the order of the derivatives of <code>g</code> whose roots the user is interested in finding; <code>newtoniter</code> is the maximum number of Newton-Raphson iterations per detected root; <code>nrabstol</code> is the allowed tolerance for the Newton-Raphson process.</p><p>The current keyword arguments are <code>maxsteps=500</code>, <code>eventorder=0</code>, <code>newtoniter=10</code>, and <code>nrabstol=eps(T)</code>, where <code>T</code> is the common type of <code>t0</code>, <code>tmax</code> and <code>abstol</code>.</p><p>The current keyword argument are:</p><ul><li><code>maxsteps=500</code>: maximum number of integration steps.</li><li><code>parse_eqs=true</code>: usie the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li><li><code>eventorder=0</code>: order of the derivative of <code>g</code> whose roots are computed.</li><li><code>newtoniter=10</code>: maximum Newton-Raphson iterations per detected root.</li><li><code>nrabstol=eps(T)</code>: allowed tolerance for the Newton-Raphson process; T is the common   type of <code>t0</code>, <code>tmax</code> and <code>abstol</code>.</li></ul><p>For more details about conventions in <code>taylorinteg</code>, please see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">    using TaylorIntegration

    function pendulum!(t, x, dx)
        dx[1] = x[2]
        dx[2] = -sin(x[1])
        nothing
    end

    g(t, x, dx) = x[2]

    x0 = [1.3, 0.0]

    # find the roots of `g` along the solution
    tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20);

    # find the roots of the 2nd derivative of `g` along the solution
    tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20; eventorder=2);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/rootfinding.jl#L100-L154">source</a><div><div><pre><code class="language-none">taylorinteg(f, g, x0, trange, order, abstol; kwargs... )</code></pre><p>Root-finding method of <code>taylorinteg</code>; returns the solution of the ODE evaluated <em>only</em> at the times specified by <code>trange</code>. Given a function <code>g(t, x, dx)</code>, called the event function, <code>taylorinteg</code> checks for the occurrence of a root of <code>g</code> evaluated at the solution; that is, it checks for the occurrence of an event or condition specified by <code>g=0</code>. Then, <code>taylorinteg</code> attempts to find that root (or event, or crossing) by performing a Newton-Raphson process. When called with the <code>eventorder=n</code> keyword argument, <code>taylorinteg</code> searches for the roots of the <code>n</code>-th derivative of <code>g</code>, which is computed via automatic differentiation.</p><p><code>maxsteps</code> is the maximum number of allowed time steps; <code>eventorder</code> is the order of the derivatives of <code>g</code> whose roots the user is interested in finding; <code>newtoniter</code> is the maximum number of Newton-Raphson iterations per detected root; <code>nrabstol</code> is the allowed tolerance for the Newton-Raphson process.</p><p>The current keyword arguments are <code>maxsteps=500</code>, <code>eventorder=0</code>, <code>newtoniter=10</code>, and <code>nrabstol=eps(T)</code>, where <code>T</code> is the common type of <code>t0</code>, <code>tmax</code> and <code>abstol</code>.</p><p>For more details about conventions in <code>taylorinteg</code>, please see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">    using TaylorIntegration

    function pendulum!(t, x, dx)
        dx[1] = x[2]
        dx[2] = -sin(x[1])
        nothing
    end

    g(t, x, dx) = x[2]

    x0 = [1.3, 0.0]

    # times at which the solution will be returned
    tv = 0.0:1.0:22.0

    # find the roots of `g` along the solution; return the solution *only* at each value of `tv`
    xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, tv, 28, 1.0E-20);

    # find the roots of the 2nd derivative of `g` along the solution; return the solution *only* at each value of `tv`
    xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, tv, 28, 1.0E-20; eventorder=2);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/rootfinding.jl#L247-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_taylorinteg" href="#TaylorIntegration.lyap_taylorinteg"><code>TaylorIntegration.lyap_taylorinteg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lyap_taylorinteg(f!, q0, t0, tmax, order, abstol[, f!]; maxsteps::Int=500)</code></pre><p>Similar to <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for the calculation of the Lyapunov spectrum. Note that the number of <code>TaylorN</code> variables should be set previously by the user (e.g., by means of <code>TaylorSeries.set_variables</code>) and should be equal to the length of the vector of initial conditions <code>q0</code>. Otherwise, whenever <code>length(q0) != TaylorSeries.get_numvars()</code>, then <code>lyap_taylorinteg</code> throws an <code>AssertionError</code>. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to evaluate the current value of the Jacobian. Otherwise, the current value of the Jacobian is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/lyapunovspectrum.jl#L198-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.@taylorize" href="#TaylorIntegration.@taylorize"><code>TaylorIntegration.@taylorize</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@taylorize expr</code></p><p>This macro <code>eval</code>s the function given by <code>expr</code> and defines a new method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> which is specialized on that function. Integrating via <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> of <a href="#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> after using the macro yields better performance.</p><p>See the <a href="../taylorize/#taylorize-1">documentation</a> for more details and limitations.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This macro is on an experimental stage; check the integration results carefully.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L788-L802">source</a></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.__jetcoeffs!-Tuple{Val{false},Any,Any,Any}" href="#TaylorIntegration.__jetcoeffs!-Tuple{Val{false},Any,Any,Any}"><code>TaylorIntegration.__jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">__jetcoeffs!(::Val{bool}, f, t, x)
__jetcoeffs!(::Val{bool}, f, t, x, dx, xaux)</code></pre><p>Chooses a method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> (hard-coded or generated by <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>) depending on <code>bool::Bool</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L87-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._capture_fn_args_body!" href="#TaylorIntegration._capture_fn_args_body!"><code>TaylorIntegration._capture_fn_args_body!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_capture_fn_args_body!(ex, vout::Dict{Symbol, Any})</code></p><p>Captures the name of a function, arguments, body and other properties, returning them as the values of the dictionary <code>dd</code>, which is updated in place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L153-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._defs_preamble!" href="#TaylorIntegration._defs_preamble!"><code>TaylorIntegration._defs_preamble!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_defs_preamble!(preamble, fnargs, d_indx, v_newindx, v_arraydecl, v_preamb,     d_decl, [inloop=false])</code></p><p>Returns a vector with expressions defining the auxiliary variables in the preamble; it may modify <code>d_indx</code> if new variables are introduced. <code>v_preamb</code> is for bookkeeping the introduced variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L621-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._extract_parts-Tuple{Expr}" href="#TaylorIntegration._extract_parts-Tuple{Expr}"><code>TaylorIntegration._extract_parts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_extract_parts(ex::Expr)</code></p><p>Returns the function name, the function arguments, and the body of a function passed as an <code>Expr</code>. The function may be provided as a one-line function, or in the long form (anonymous functions do not work).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L96-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._make_parsed_jetcoeffs" href="#TaylorIntegration._make_parsed_jetcoeffs"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_make_parsed_jetcoeffs( ex, debug=false )</code></p><p>This function constructs a new function, equivalent to the differential equations, which exploits the mutating functions of TaylorSeries.jl.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L35-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._newfnbody-Tuple{Any,Any}" href="#TaylorIntegration._newfnbody-Tuple{Any,Any}"><code>TaylorIntegration._newfnbody</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_newfnbody(fnbody, d_indx)</code></p><p>Returns a new (modified) body of the function, a priori unfolding the expression graph (AST) as unary and binary calls, and a vector (<code>v_newindx</code>) with the name of auxiliary indexed variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L304-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._newhead-Tuple{Any,Any}" href="#TaylorIntegration._newhead-Tuple{Any,Any}"><code>TaylorIntegration._newhead</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_newhead(fn, fnargs)</code></p><p>Creates the head of the new method of <code>jetcoeffs!</code>. Here, <code>fn</code> is the name of the passed function and <code>fnargs</code> is a vector with its arguments (which are two or three).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L179-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._parse_newfnbody!" href="#TaylorIntegration._parse_newfnbody!"><code>TaylorIntegration._parse_newfnbody!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_parse_newfnbody!(ex, preex, v_vars, v_assign, d_indx, v_newindx, v_arraydecl,     [inloop=false])</code></p><p>Parses <code>ex</code> (the new body of the function) replacing the expressions to use the mutating functions of TaylorSeries, and building the preamble <code>preex</code>. This is done by traversing recursively the args of <code>ex</code>, updating the bookkeeping vectors <code>v_vars</code> and <code>v_assign</code>. <code>d_indx</code> is used to substitute back the explicit indexed variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L412-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._preamble_body" href="#TaylorIntegration._preamble_body"><code>TaylorIntegration._preamble_body</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>_preamble_body(fnbody, fnargs, debug=false)</code></p><p>Returns the preamble, the body and a guessed return variable, which will be used to build the parsed function. <code>fnbody</code> is the expression with the body of the original function, <code>fnargs</code> is a vector of symbols of the original diferential equations function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L211-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._recursionloop-Tuple{Any,Any}" href="#TaylorIntegration._recursionloop-Tuple{Any,Any}"><code>TaylorIntegration._recursionloop</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_recursionloop(fnargs, retvar)</code></p><p>Build the expression for the recursion-loop.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L748-L753">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._rename_indexedvars-Tuple{Any}" href="#TaylorIntegration._rename_indexedvars-Tuple{Any}"><code>TaylorIntegration._rename_indexedvars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_rename_indexedvars(fnbody)</code></p><p>Renames the indexed variables (using <code>Espresso.genname()</code>) that exists in <code>fnbody</code>. Returns <code>fnbody</code> with the renamed variables and a dictionary that links the new variables to the old indexed ones.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L284-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._replace_expr!-Tuple{Expr,Expr,Int64,Any,Any,Any,Any,Any}" href="#TaylorIntegration._replace_expr!-Tuple{Expr,Expr,Int64,Any,Any,Any,Any,Any}"><code>TaylorIntegration._replace_expr!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_replace_expr!(ex, preex, i, aalhs, aarhs, v_vars, d_indx, v_newindx)</code></p><p>Replaces the calls in <code>ex.args[i]</code>, and updates <code>preex</code> with the definitions of the expressions, based on the the LHS (<code>aalhs</code>) and RHS (<code>aarhs</code>) of the base assignment. The bookkeeping vectors (<code>v_vars</code>, <code>v_newindx</code>) are updated. <code>d_indx</code> is used to bring back the indexed variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L508-L516">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration._replacecalls!-Tuple{Expr,Symbol,Any}" href="#TaylorIntegration._replacecalls!-Tuple{Expr,Symbol,Any}"><code>TaylorIntegration._replacecalls!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>_replacecalls!(fnold, newvar, v_vars)</code></p><p>Replaces the symbols of unary and binary calls of the expression <code>fnold</code>, which defines <code>newvar</code>, by the mutating functions in TaylorSeries.jl. The vector <code>v_vars</code> is updated if new auxiliary variables are introduced.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/parse_eqs.jl#L545-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.findroot!-NTuple{19,Any}" href="#TaylorIntegration.findroot!-NTuple{19,Any}"><code>TaylorIntegration.findroot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findroot!(g, t, x, dx, g_val_old, g_val, eventorder, tvS, xvS, gvS,
    t0, δt_old, x_dx, x_dx_val, g_dg, g_dg_val, nrabstol,
    newtoniter, nevents) -&gt; nevents</code></pre><p>Internal root-finding subroutine, based on Newton-Raphson process. If there is a crossing, then the crossing data is stored in <code>tvS</code>, <code>xvS</code> and <code>gvS</code> and <code>nevents</code>, the number of events/crossings, is updated. <code>g</code> is the event function, <code>t</code> is a <code>Taylor1</code> polynomial which represents the independent variable; <code>x</code> is an array of <code>Taylor1</code> variables which represent the vector of dependent variables; <code>dx</code> is an array of <code>Taylor1</code> variables which represent the LHS of the ODE; <code>g_val_old</code> is the last-before-current value of event function <code>g</code>; <code>g_val</code> is the current value of the event function <code>g</code>; <code>eventorder</code> is the order of the derivative of <code>g</code> whose roots the user is interested in finding; <code>tvS</code> stores the surface-crossing instants; <code>xvS</code> stores the value of the solution at each of the crossings; <code>gvS</code> stores the values of the event function <code>g</code> (or its <code>eventorder</code>-th derivative) at each of the crossings; <code>t0</code> is the current time; <code>δt_old</code> is the last time-step size; <code>x_dx</code>, <code>x_dx_val</code>, <code>g_dg</code>, <code>g_dg_val</code> are auxiliary variables; <code>nrabstol</code> is the Newton-Raphson process tolerance; <code>newtoniter</code> is the maximum allowed number of Newton-Raphson iteration; <code>nevents</code> is the current number of detected events/crossings.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/rootfinding.jl#L36-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">jetcoeffs!(eqsdiff!::Function, t, x, dx, xaux)</code></pre><p>Mutates <code>x</code> in-place using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(t,x)$</span>.</p><p><code>eqsdiff!</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variables and <code>t</code> is the independent variable. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and structure of <code>eqsdiff!</code>. Note that <code>x</code> is of type <code>Vector{Taylor1{U}}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>. In this case, two auxiliary containers <code>dx</code> and <code>xaux</code> (both of the same type as <code>x</code>) are needed to avoid allocations.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},Taylor1{U}}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},Taylor1{U}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">jetcoeffs!(eqsdiff::Function, t, x)</code></pre><p>Returns an updated <code>x</code> using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(t,x)$</span>.</p><p><code>eqsdiff</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variable(s) and <code>t</code> is the independent variable. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and structure of <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Taylor1{U}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lyap_jetcoeffs!(t, x, dx, jac, varsaux)</code></pre><p>Similar to <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> for the calculation of the Lyapunov spectrum. Updates <em>only</em> the elements of <code>x</code> which correspond to the solution of the 1st-order variational equations <span>$\dot{\xi}=J \cdot \xi$</span>, where <span>$J$</span> is the Jacobian matrix, i.e., the linearization of the equations of motion. <code>jac</code> is the Taylor expansion of <span>$J$</span> wrt the independent variable, around the current initial condition. <code>varsaux</code> is an auxiliary array of type <code>Array{eltype(jac),3}</code> to avoid allocations. Calling this method assumes that <code>jac</code> has been computed previously using <a href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real"><code>stabilitymatrix!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/lyapunovspectrum.jl#L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Bool,Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Bool,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lyap_taylorstep!(f!, t, x, dx, xaux, δx, dδx, jac, t0, t1, x0, order, abstol, _δv, varsaux[, jacobianfunc!])</code></pre><p>Similar to <a href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T,Bool}} where U&lt;:Number where T&lt;:Real"><code>taylorstep!</code></a> for the calculation of the Lyapunov spectrum. <code>jac</code> is the Taylor expansion (wrt the independent variable) of the linearization of the equations of motion, i.e, the Jacobian. <code>xaux</code>, <code>δx</code>, <code>dδx</code>, <code>varsaux</code> and <code>_δv</code> are auxiliary vectors. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/lyapunovspectrum.jl#L157-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number" href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number"><code>TaylorIntegration.nrconvergencecriterion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nrconvergencecriterion(g_val, nrabstol::T, nriter::Int, newtoniter::Int) where {T&lt;:Real}</code></pre><p>A rudimentary convergence criterion for the Newton-Raphson root-finding process. <code>g_val</code> may be either a <code>Real</code>, <code>Taylor1{T}</code> or a <code>TaylorN{T}</code>, where <code>T&lt;:Real</code>. Returns <code>true</code> if: 1) the absolute value of <code>g_val</code>, the event function <code>g</code> evaluated at the current estimated root by the Newton-Raphson process, is less than the <code>nrabstol</code> tolerance; and 2) the number of iterations <code>nriter</code> of the Newton-Raphson process is less than the maximum allowed number of iterations, <code>newtoniter</code>; otherwise, returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/rootfinding.jl#L22-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stabilitymatrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stabilitymatrix!(eqsdiff!, t, x, δx, dδx, jac, _δv[, jacobianfunc!])</code></pre><p>Updates the matrix <code>jac::Matrix{Taylor1{U}}</code> (linearized equations of motion) computed from the equations of motion (<code>eqsdiff!</code>), at time <code>t</code> at <code>x</code>; <code>x</code> is of type <code>Vector{Taylor1{U}}</code>, where <code>U&lt;:Number</code>. <code>δx</code>, <code>dδx</code> and <code>_δv</code> are auxiliary arrays of type <code>Vector{TaylorN{Taylor1{U}}}</code> to avoid allocations. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/lyapunovspectrum.jl#L3-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stepsize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stepsize(x, epsilon) -&gt; h</code></pre><p>Returns a maximum time-step for a the Taylor expansion <code>x</code> using a prescribed absolute tolerance <code>epsilon</code> and the last two Taylor coefficients of (each component of) <code>x</code>.</p><p>Note that <code>x</code> is of type <code>Taylor1{T}</code> or <code>Vector{Taylor1{T}}</code>, including also the cases <code>Taylor1{TaylorN{T}}</code> and <code>Vector{Taylor1{TaylorN{T}}}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L101-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Int64}} where T&lt;:Number" href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">surfacecrossing(g_old, g_now, eventorder::Int)</code></pre><p>Detect if the solution crossed a root of event function <code>g</code>. <code>g_old</code> represents the last-before-current value of event function <code>g</code>; <code>g_now</code> represents the current value of event function <code>g</code>; <code>eventorder</code> is the order of the derivative of the event function <code>g</code> whose root we are trying to find. Returns <code>true</code> if <code>g_old</code> and <code>g_now</code> have different signs (i.e., if one is positive and the other one is negative). Otherwise, if <code>g_old</code> and <code>g_now</code> have the same sign or if either one of them are a <code>nothing</code> value, then returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/rootfinding.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T,Bool}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T,Bool}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">taylorstep!(f!, t, x, dx, xaux, t0, t1, x0, order, abstol, parse_eqs=true) -&gt; δt</code></pre><p>One-step Taylor integration for the ODE <span>$\dot{x}=dx/dt=f(t, x)$</span> with initial conditions <span>$x(t_0)=x_0$</span>, computed from <code>t0</code> up to <code>t1</code>, returning the time-step of the actual integration carried out and updating (in-place) <code>x0</code>.</p><p>Here, <code>f!</code> is the function defining the RHS of the ODE (see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and structure of <code>f!</code>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variables, <code>x0</code> corresponds to the initial (and updated) dependent variables and is of type <code>Vector{Taylor1{T&lt;:Number}}</code>, <code>order</code> is the degree used for the <code>Taylor1</code> polynomials during the integration and <code>abstol</code> is the absolute tolerance used to determine the time step of the integration.  <code>dx</code> and <code>xaux</code>, both of the same type as <code>x0</code>, are needed to avoid allocations. Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations).</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T,Bool}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T,Bool}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">taylorstep!(f, t, x, t0, t1, x0, order, abstol, parse_eqs=true) -&gt; δt, x0</code></pre><p>One-step Taylor integration for the ODE <span>$\dot{x}=dx/dt=f(t, x)$</span> with initial conditions <span>$x(t_0)=x_0$</span>, computed from <code>t0</code> up to <code>t1</code>. Returns the time-step of the actual integration carried out and the updated value of <code>x0</code>.</p><p>Here, <code>f</code> is the function defining the RHS of the ODE (see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and structure of <code>f</code>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variable,<code>x0</code> is the initial value of the dependent variable, <code>order</code> is the degree  used for the <code>Taylor1</code> polynomials during the integration and <code>abstol</code> is the absolute tolerance used to determine the time step of the integration. Note that <code>x0</code> is of type <code>Taylor1{T&lt;:Number}</code> or <code>Taylor1{TaylorN{T}}</code>. If the time step is larger than <code>t1-t0</code>, that difference is used as the time step. Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations).</p></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/fba76349b97e35197694888a7ff969a7d1320a10/src/explicitode.jl#L152">source</a></section><footer><hr/><a class="previous" href="../taylorize/"><span class="direction">Previous</span><span class="title">Optimizing: <code>@taylorize</code></span></a></footer></article></body></html>
