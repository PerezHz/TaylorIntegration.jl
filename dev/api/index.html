<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorIntegration.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TaylorIntegration.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../taylor_method/">Taylor&#39;s method</a></li><li><a class="tocitem" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="tocitem" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../simple_example/">Infinity in finite time</a></li><li><a class="tocitem" href="../kepler/">The Kepler problem</a></li><li><a class="tocitem" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="tocitem" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="tocitem" href="../root_finding/">Poincaré maps</a></li><li><a class="tocitem" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li><a class="tocitem" href="../taylorize/">Optimizing: <code>@taylorize</code></a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-functions-1"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Internal-1"><span>Internal</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-1"><a class="docs-heading-anchor" href="#Library-1">Library</a><a class="docs-heading-anchor-permalink" href="#Library-1" title="Permalink"></a></h1><hr/><h2 id="Exported-functions-1"><a class="docs-heading-anchor" href="#Exported-functions-1">Exported functions</a><a class="docs-heading-anchor-permalink" href="#Exported-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.taylorinteg" href="#TaylorIntegration.taylorinteg"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">taylorinteg(f, x0, t0, tmax, order, abstol, params[=nothing]; kwargs... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(x, p, t)$</span>. The initial condition are specified by <code>x0</code> at time <code>t0</code>, and any parameters encoded in <code>params</code>. The initial condition <code>x0</code> may be of type <code>T&lt;:Number</code> or <code>Vector{T}</code>, with <code>T</code> including <code>TaylorN{T}</code>; the latter case is of interest for <a href="../jet_transport/#jettransport-1">jet transport applications</a>.</p><p>The equations of motion are specified by the function <code>f</code>; we follow the same convention of <code>DifferentialEquations.jl</code> to define this function, i.e., <code>f(x, p, t)</code> or <code>f!(dx, x, p, t)</code>; see the examples below.</p><p>It returns a vector with the values of time (independent variable), and a vector with the computed values of the dependent variable(s). The integration stops when time is larger than <code>tmax</code>, in which case the last returned value(s) correspond to that time, or when the number of saved steps is larger than <code>maxsteps</code>.</p><p>The integration method uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>Currently, the recognized keyword arguments are:</p><ul><li><code>maxsteps[=500]</code>: maximum number of integration steps.</li><li><code>parse_eqs[=true]</code>: use the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li></ul><p><strong>Examples</strong></p><p>For one dependent variable the function <code>f</code> defines the RHS of the equation of motion, returning the value of <span>$\dot{x}$</span>. The arguments of this function are <code>(x, p, t)</code>, where <code>x</code> are the dependent variables, <code>p</code> are the paremeters and <code>t</code> is the independent variable.</p><p>For several (two or more) dependent variables, the function <code>f!</code> defines the RHS of the equations of motion, mutating (in-place) the (preallocated) vector with components of <span>$\dot{x}$</span>. The arguments of this function are <code>(dx, x, p, t)</code>, where <code>dx</code> is the preallocated vector of <span>$\dot{x}$</span>, <code>x</code> are the dependent variables, <code>p</code> are the paremeters entering the ODEs and <code>t</code> is the independent variable. The function may return this vector or simply <code>nothing</code>.</p><pre><code class="language-julia">using TaylorIntegration

f(x, p, t) = x^2

tv, xv = taylorinteg(f, 3, 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )

function f!(dx, x, p, t)
    for i in eachindex(x)
        dx[i] = x[i]^2
    end
    return nothing
end

tv, xv = taylorinteg(f!, [3, 3], 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L287">source</a></section><section><div><pre><code class="language-none">taylorinteg(f, x0, trange, order, abstol, params[=nothing]; keyword... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(t,x)$</span> with initial condition specified by <code>x0::{T&lt;:Number}</code> or <code>x0::Vector{T}</code> at time <code>t0</code>.</p><p>The method returns a vector with the computed values of the dependent variable(s), evaluated <em>only</em> at the times specified by the range <code>trange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">xv = taylorinteg(f, 3, 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 )

xv = taylorinteg(f!, [3, 3], 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 );
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L451">source</a></section><section><div><pre><code class="language-none">taylorinteg(f, g, x0, t0, tmax, order, abstol, params[=nothing]; kwargs... )

taylorinteg(f, g, x0, trange, order, abstol; kwargs... )</code></pre><p>Root-finding method of <code>taylorinteg</code>.</p><p>Given a function <code>g(dx, x, params, t)::Tuple{Bool, Taylor1{T}}</code>, called the event function, <code>taylorinteg</code> checks for the occurrence of a root or event defined by <code>cond2 == 0</code> (<code>cond2::Taylor1{T}</code>) if <code>cond1::Bool</code> is satisfied (<code>true</code>); <code>g</code> is thus assumed to return the tuple (cond1, cond2). Then, <code>taylorinteg</code> attempts to find that root (or event, or crossing) by performing a Newton-Raphson process. When called with the <code>eventorder=n</code> keyword argument, <code>taylorinteg</code> searches for the roots of the <code>n</code>-th derivative of <code>cond2</code>, which is computed via automatic differentiation.</p><p>The current keyword argument are:</p><ul><li><code>maxsteps[=500]</code>: maximum number of integration steps.</li><li><code>parse_eqs[=true]</code>: use the specialized method of <code>jetcoeffs!</code> created   with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>.</li><li><code>eventorder[=0]</code>: order of the derivative of <code>g</code> whose roots are computed.</li><li><code>newtoniter[=10]</code>: maximum Newton-Raphson iterations per detected root.</li><li><code>nrabstol[=eps(T)]</code>: allowed tolerance for the Newton-Raphson process; T is the common   type of <code>t0</code>, <code>tmax</code> (or <code>eltype(trange)</code>) and <code>abstol</code>.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia">using TaylorIntegration

function pendulum!(dx, x, params, t)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    nothing
end

g(dx, x, params, t) = (true, x[2])

x0 = [1.3, 0.0]

# find the roots of `g` along the solution
tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20)

# find the roots of the 2nd derivative of `g` along the solution
tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20; eventorder=2)

# times at which the solution will be returned
tv = 0.0:1.0:22.0

# find the roots of `g` along the solution; return the solution *only* at each value of `tv`
xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, tv, 28, 1.0E-20)

# find the roots of the 2nd derivative of `g` along the solution; return the solution *only* at each value of `tv`
xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, tv, 28, 1.0E-20; eventorder=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/rootfinding.jl#L102-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.lyap_taylorinteg" href="#TaylorIntegration.lyap_taylorinteg"><code>TaylorIntegration.lyap_taylorinteg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lyap_taylorinteg(f!, q0, t0, tmax, order, abstol[, f!]; maxsteps::Int=500)</code></pre><p>Similar to <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for the calculation of the Lyapunov spectrum. Note that the number of <code>TaylorN</code> variables should be set previously by the user (e.g., by means of <code>TaylorSeries.set_variables</code>) and should be equal to the length of the vector of initial conditions <code>q0</code>. Otherwise, whenever <code>length(q0) != TaylorSeries.get_numvars()</code>, then <code>lyap_taylorinteg</code> throws an <code>AssertionError</code>. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to evaluate the current value of the Jacobian. Otherwise, the current value of the Jacobian is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/lyapunovspectrum.jl#L196-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.@taylorize" href="#TaylorIntegration.@taylorize"><code>TaylorIntegration.@taylorize</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><code>@taylorize expr</code></p><p>This macro <code>eval</code>s the function given by <code>expr</code> and defines a new method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> which is specialized on that function. Integrating via <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> of <a href="#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> after using the macro yields better performance.</p><p>See the <a href="../taylorize/#taylorize-1">documentation</a> for more details and limitations.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This macro is on an experimental stage; check the integration results carefully.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L823-L837">source</a></section></article><h2 id="Internal-1"><a class="docs-heading-anchor" href="#Internal-1">Internal</a><a class="docs-heading-anchor-permalink" href="#Internal-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.__jetcoeffs!-Tuple{Val{false},Any,Any,Any,Any}" href="#TaylorIntegration.__jetcoeffs!-Tuple{Val{false},Any,Any,Any,Any}"><code>TaylorIntegration.__jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">__jetcoeffs!(::Val{bool}, f, t, x, params)
__jetcoeffs!(::Val{bool}, f, t, x, dx, xaux, params)</code></pre><p>Chooses a method of <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> (hard-coded or generated by <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>) depending on <code>Val{bool}</code> (<code>bool::Bool</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._capture_fn_args_body!" href="#TaylorIntegration._capture_fn_args_body!"><code>TaylorIntegration._capture_fn_args_body!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_capture_fn_args_body!(ex, vout::Dict{Symbol, Any})</code></p><p>Captures the name of a function, arguments, body and other properties, returning them as the values of the dictionary <code>dd</code>, which is updated in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L156-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._defs_preamble!" href="#TaylorIntegration._defs_preamble!"><code>TaylorIntegration._defs_preamble!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_defs_preamble!(preamble, fnargs, d_indx, v_newindx, v_arraydecl, v_preamb,     d_decl, [inloop=false])</code></p><p>Returns a vector with expressions defining the auxiliary variables in the preamble; it may modify <code>d_indx</code> if new variables are introduced. <code>v_preamb</code> is for bookkeeping the introduced variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L657-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._determine_parsing!-Tuple{Bool,Any,Any,Any,Any}" href="#TaylorIntegration._determine_parsing!-Tuple{Bool,Any,Any,Any,Any}"><code>TaylorIntegration._determine_parsing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_determine_parsing!(parse_eqs::Bool, f, t, x, params)
_determine_parsing!(parse_eqs::Bool, f, t, x, dx, params)</code></pre><p>Check if the parsed method of <code>jetcoeffs!</code> exists and check it runs without error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._extract_parts-Tuple{Expr}" href="#TaylorIntegration._extract_parts-Tuple{Expr}"><code>TaylorIntegration._extract_parts</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_extract_parts(ex::Expr)</code></p><p>Returns the function name, the function arguments, and the body of a function passed as an <code>Expr</code>. The function may be provided as a one-line function, or in the long form (anonymous functions do not work).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._make_parsed_jetcoeffs" href="#TaylorIntegration._make_parsed_jetcoeffs"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_make_parsed_jetcoeffs( ex, debug=false )</code></p><p>This function constructs a new function, equivalent to the differential equations, which exploits the mutating functions of TaylorSeries.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._newfnbody-Tuple{Any,Any,Any}" href="#TaylorIntegration._newfnbody-Tuple{Any,Any,Any}"><code>TaylorIntegration._newfnbody</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_newfnbody(fnbody, fnargs, d_indx)</code></p><p>Returns a new (modified) body of the function, a priori unfolding the expression graph (AST) as unary and binary calls, and a vector (<code>v_newindx</code>) with the name of auxiliary indexed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L307-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._newhead-Tuple{Any,Any}" href="#TaylorIntegration._newhead-Tuple{Any,Any}"><code>TaylorIntegration._newhead</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_newhead(fn, fnargs)</code></p><p>Creates the head of the new method of <code>jetcoeffs!</code>. Here, <code>fn</code> is the name of the passed function and <code>fnargs</code> is a vector with its arguments (which are two or three).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._parse_newfnbody!" href="#TaylorIntegration._parse_newfnbody!"><code>TaylorIntegration._parse_newfnbody!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_parse_newfnbody!(ex, preex, v_vars, v_assign, d_indx, v_newindx, v_arraydecl,     [inloop=false])</code></p><p>Parses <code>ex</code> (the new body of the function) replacing the expressions to use the mutating functions of TaylorSeries, and building the preamble <code>preex</code>. This is done by traversing recursively the args of <code>ex</code>, updating the bookkeeping vectors <code>v_vars</code> and <code>v_assign</code>. <code>d_indx</code> is used to substitute back the explicit indexed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._preamble_body" href="#TaylorIntegration._preamble_body"><code>TaylorIntegration._preamble_body</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>_preamble_body(fnbody, fnargs, debug=false)</code></p><p>Returns the preamble, the body and a guessed return variable, which will be used to build the parsed function. <code>fnbody</code> is the expression with the body of the original function, <code>fnargs</code> is a vector of symbols of the original diferential equations function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._recursionloop-Tuple{Any,Any}" href="#TaylorIntegration._recursionloop-Tuple{Any,Any}"><code>TaylorIntegration._recursionloop</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_recursionloop(fnargs, retvar)</code></p><p>Build the expression for the recursion-loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L784-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._rename_indexedvars-Tuple{Any}" href="#TaylorIntegration._rename_indexedvars-Tuple{Any}"><code>TaylorIntegration._rename_indexedvars</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_rename_indexedvars(fnbody)</code></p><p>Renames the indexed variables (using <code>Espresso.genname()</code>) that exists in <code>fnbody</code>. Returns <code>fnbody</code> with the renamed variables and a dictionary that links the new variables to the old indexed ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L287-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._replace_expr!-Tuple{Expr,Expr,Int64,Any,Any,Any,Any,Any}" href="#TaylorIntegration._replace_expr!-Tuple{Expr,Expr,Int64,Any,Any,Any,Any,Any}"><code>TaylorIntegration._replace_expr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_replace_expr!(ex, preex, i, aalhs, aarhs, v_vars, d_indx, v_newindx)</code></p><p>Replaces the calls in <code>ex.args[i]</code>, and updates <code>preex</code> with the definitions of the expressions, based on the the LHS (<code>aalhs</code>) and RHS (<code>aarhs</code>) of the base assignment. The bookkeeping vectors (<code>v_vars</code>, <code>v_newindx</code>) are updated. <code>d_indx</code> is used to bring back the indexed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L544-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._replacecalls!-Tuple{Expr,Symbol,Any}" href="#TaylorIntegration._replacecalls!-Tuple{Expr,Symbol,Any}"><code>TaylorIntegration._replacecalls!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_replacecalls!(fnold, newvar, v_vars)</code></p><p>Replaces the symbols of unary and binary calls of the expression <code>fnold</code>, which defines <code>newvar</code>, by the mutating functions in TaylorSeries.jl. The vector <code>v_vars</code> is updated if new auxiliary variables are introduced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/parse_eqs.jl#L581-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration._second_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_second_stepsize(x, epsilon)</code></pre><p>Corresponds to the &quot;second stepsize control&quot; in Jorba and Zou (2005) paper. We use it if <a href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>stepsize</code></a> returns <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U,T,Int64}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U,T,Int64}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration._stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_stepsize(aux1, epsilon, k)</code></pre><p>Helper function to avoid code repetition. Returns <span>$(epsilon/aux1)^(1/k)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.findroot!-NTuple{18,Any}" href="#TaylorIntegration.findroot!-NTuple{18,Any}"><code>TaylorIntegration.findroot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findroot!(t, x, dx, g_tupl_old, g_tupl, eventorder, tvS, xvS, gvS,
    t0, δt_old, x_dx, x_dx_val, g_dg, g_dg_val, nrabstol,
    newtoniter, nevents) -&gt; nevents</code></pre><p>Internal root-finding subroutine, based on Newton-Raphson process. If there is a crossing, then the crossing data is stored in <code>tvS</code>, <code>xvS</code> and <code>gvS</code> and <code>nevents</code>, the number of events/crossings, is updated. Here <code>t</code> is a <code>Taylor1</code> polynomial which represents the independent variable; <code>x</code> is an array of <code>Taylor1</code> variables which represent the vector of dependent variables; <code>dx</code> is an array of <code>Taylor1</code> variables which represent the LHS of the ODE; <code>g_tupl_old</code> is the last-before-current value returned by event function <code>g</code> and <code>g_tupl</code> is the current one; <code>eventorder</code> is the order of the derivative of <code>g</code> whose roots the user is interested in finding; <code>tvS</code> stores the surface-crossing instants; <code>xvS</code> stores the value of the solution at each of the crossings; <code>gvS</code> stores the values of the event function <code>g</code> (or its <code>eventorder</code>-th derivative) at each of the crossings; <code>t0</code> is the current time; <code>δt_old</code> is the last time-step size; <code>x_dx</code>, <code>x_dx_val</code>, <code>g_dg</code>, <code>g_dg_val</code> are auxiliary variables; <code>nrabstol</code> is the Newton-Raphson process tolerance; <code>newtoniter</code> is the maximum allowed number of Newton-Raphson iteration; <code>nevents</code> is the current number of detected events/crossings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/rootfinding.jl#L36-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jetcoeffs!(eqsdiff!::Function, t, x, dx, xaux, params)</code></pre><p>Mutates <code>x</code> in-place using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(x, p, t)$</span>.</p><p><code>eqsdiff!</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variables and <code>t</code> is the independent variable, and <code>params</code> are the parameters appearing on the function defining the differential equation. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and convention for <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Vector{Taylor1{U}}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>. In this case, two auxiliary containers <code>dx</code> and <code>xaux</code> (both of the same type as <code>x</code>) are needed to avoid allocations.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},Taylor1{U},Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},Taylor1{U},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jetcoeffs!(eqsdiff::Function, t, x, params)</code></pre><p>Returns an updated <code>x</code> using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(x, p, t)$</span>.</p><p><code>eqsdiff</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variable(s) and <code>t</code> is the independent variable, and <code>params</code> are the parameters appearing on the function defining the differential equation. See <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> for examples and convention for <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Taylor1{U}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_jetcoeffs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lyap_jetcoeffs!(t, x, dx, jac, varsaux)</code></pre><p>Similar to <a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> for the calculation of the Lyapunov spectrum. Updates <em>only</em> the elements of <code>x</code> which correspond to the solution of the 1st-order variational equations <span>$\dot{\xi}=J \cdot \xi$</span>, where <span>$J$</span> is the Jacobian matrix, i.e., the linearization of the equations of motion. <code>jac</code> is the Taylor expansion of <span>$J$</span> wrt the independent variable, around the current initial condition. <code>varsaux</code> is an auxiliary array of type <code>Array{eltype(jac),3}</code> to avoid allocations. Calling this method assumes that <code>jac</code> has been computed previously using <a href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any,Any}} where U&lt;:Number where T&lt;:Real"><code>stabilitymatrix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/lyapunovspectrum.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool,Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_taylorstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lyap_taylorstep!(f!, t, x, dx, xaux, δx, dδx, jac, t0, t1, order, abstol, _δv, varsaux, params[, jacobianfunc!])</code></pre><p>Similar to <a href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any,Bool}} where U&lt;:Number where T&lt;:Real"><code>taylorstep!</code></a> for the calculation of the Lyapunov spectrum. <code>jac</code> is the Taylor expansion (wrt the independent variable) of the linearization of the equations of motion, i.e, the Jacobian. <code>xaux</code>, <code>δx</code>, <code>dδx</code>, <code>varsaux</code> and <code>_δv</code> are auxiliary vectors, and <code>params</code> define the parameters of the ODEs. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/lyapunovspectrum.jl#L157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number" href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number"><code>TaylorIntegration.nrconvergencecriterion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nrconvergencecriterion(g_val, nrabstol::T, nriter::Int, newtoniter::Int) where {T&lt;:Real}</code></pre><p>A rudimentary convergence criterion for the Newton-Raphson root-finding process. <code>g_val</code> may be either a <code>Real</code>, <code>Taylor1{T}</code> or a <code>TaylorN{T}</code>, where <code>T&lt;:Real</code>. Returns <code>true</code> if: 1) the absolute value of <code>g_val</code>, the value of the event function <code>g</code> evaluated at the current estimated root by the Newton-Raphson process, is less than the <code>nrabstol</code> tolerance; and 2) the number of iterations <code>nriter</code> of the Newton-Raphson process is less than the maximum allowed number of iterations, <code>newtoniter</code>; otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/rootfinding.jl#L21-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any,Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stabilitymatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stabilitymatrix!(eqsdiff!, t, x, δx, dδx, jac, _δv, params[, jacobianfunc!=nothing])</code></pre><p>Updates the matrix <code>jac::Matrix{Taylor1{U}}</code> (linearized equations of motion) computed from the equations of motion (<code>eqsdiff!</code>), at time <code>t</code> at <code>x</code>; <code>x</code> is of type <code>Vector{Taylor1{U}}</code>, where <code>U&lt;:Number</code>. <code>δx</code>, <code>dδx</code> and <code>_δv</code> are auxiliary arrays of type <code>Vector{TaylorN{Taylor1{U}}}</code> to avoid allocations. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/lyapunovspectrum.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepsize(x, epsilon) -&gt; h</code></pre><p>Returns a maximum time-step for a the Taylor expansion <code>x</code> using a prescribed absolute tolerance <code>epsilon</code> and the last two Taylor coefficients of (each component of) <code>x</code>.</p><p>Note that <code>x</code> is of type <code>Taylor1{U}</code> or <code>Vector{Taylor1{U}}</code>, including also the cases <code>Taylor1{TaylorN{U}}</code> and <code>Vector{Taylor1{TaylorN{U}}}</code>.</p><p>Depending of <code>eltype(x)</code>, i.e., <code>U&lt;:Number</code>, it may be necessary to overload <code>stepsize</code>, specializing it on the type <code>U</code>, to avoid type instabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L108-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool,Taylor1{T}},Tuple{Bool,Taylor1{T}},Int64}} where T&lt;:Number" href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool,Taylor1{T}},Tuple{Bool,Taylor1{T}},Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surfacecrossing(g_old, g_now, eventorder::Int)</code></pre><p>Detect if the solution crossed a root of event function <code>g</code>. <code>g_old</code> represents the last-before-current value of event function <code>g</code>, and <code>g_now</code> represents the current one; these are <code>Tuple{Bool,Taylor1{T}}</code>s. <code>eventorder</code> is the order of the derivative of the event function <code>g</code> whose root we are trying to find. Returns <code>true</code> if the constant terms of <code>g_old[2]</code> and <code>g_now[2]</code> have different signs (i.e., if one is positive and the other one is negative). Otherwise, if <code>g_old[2]</code> and <code>g_now[2]</code> have the same sign or if the first component of either of them is <code>false</code>, then it returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/rootfinding.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any,Bool}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any,Bool}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">taylorstep!(f, t, x, t0, order, abstol, params, parse_eqs=true) -&gt; δt
taylorstep!(f!, t, x, dx, xaux, t0, order, abstol, params, parse_eqs=true) -&gt; δt</code></pre><p>One-step Taylor integration for the one-dependent variable ODE <span>$\dot{x}=dx/dt=f(x, p, t)$</span> with initial conditions <span>$x(t_0)=x_0$</span>. Returns the time-step <code>δt</code> of the actual integration carried out (δt is positive).</p><p>Here, <code>f</code> is the function defining the RHS of the ODE (see <a href="#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variable, <code>order</code> is the degree  used for the <code>Taylor1</code> polynomials during the integration <code>abstol</code> is the absolute tolerance used to determine the time step of the integration, and <code>params</code> are the parameters entering the ODE functions. For several variables, <code>dx</code> and <code>xaux</code>, both of the same type as <code>x</code>, are needed to save allocations. Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations). Finally, <code>parse_eqs</code> is a switch to force <em>not</em> using (<code>parse_eqs=false</code>) the specialized method of <code>jetcoeffs!</code> created with <a href="#TaylorIntegration.@taylorize"><code>@taylorize</code></a>; the default is <code>true</code> (parse the equations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/c3227a0c193279e6e195eceda98a5ccd7cd8814a/src/explicitode.jl#L192">source</a></section></article><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#TaylorIntegration.__jetcoeffs!-Tuple{Val{false},Any,Any,Any,Any}"><code>TaylorIntegration.__jetcoeffs!</code></a></li><li><a href="#TaylorIntegration._capture_fn_args_body!"><code>TaylorIntegration._capture_fn_args_body!</code></a></li><li><a href="#TaylorIntegration._defs_preamble!"><code>TaylorIntegration._defs_preamble!</code></a></li><li><a href="#TaylorIntegration._determine_parsing!-Tuple{Bool,Any,Any,Any,Any}"><code>TaylorIntegration._determine_parsing!</code></a></li><li><a href="#TaylorIntegration._extract_parts-Tuple{Expr}"><code>TaylorIntegration._extract_parts</code></a></li><li><a href="#TaylorIntegration._make_parsed_jetcoeffs"><code>TaylorIntegration._make_parsed_jetcoeffs</code></a></li><li><a href="#TaylorIntegration._newfnbody-Tuple{Any,Any,Any}"><code>TaylorIntegration._newfnbody</code></a></li><li><a href="#TaylorIntegration._newhead-Tuple{Any,Any}"><code>TaylorIntegration._newhead</code></a></li><li><a href="#TaylorIntegration._parse_newfnbody!"><code>TaylorIntegration._parse_newfnbody!</code></a></li><li><a href="#TaylorIntegration._preamble_body"><code>TaylorIntegration._preamble_body</code></a></li><li><a href="#TaylorIntegration._recursionloop-Tuple{Any,Any}"><code>TaylorIntegration._recursionloop</code></a></li><li><a href="#TaylorIntegration._rename_indexedvars-Tuple{Any}"><code>TaylorIntegration._rename_indexedvars</code></a></li><li><a href="#TaylorIntegration._replace_expr!-Tuple{Expr,Expr,Int64,Any,Any,Any,Any,Any}"><code>TaylorIntegration._replace_expr!</code></a></li><li><a href="#TaylorIntegration._replacecalls!-Tuple{Expr,Symbol,Any}"><code>TaylorIntegration._replacecalls!</code></a></li><li><a href="#TaylorIntegration._second_stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration._second_stepsize</code></a></li><li><a href="#TaylorIntegration._stepsize-Union{Tuple{U}, Tuple{T}, Tuple{U,T,Int64}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration._stepsize</code></a></li><li><a href="#TaylorIntegration.findroot!-NTuple{18,Any}"><code>TaylorIntegration.findroot!</code></a></li><li><a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},Taylor1{U},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_jetcoeffs!</code></a></li><li><a href="#TaylorIntegration.lyap_taylorinteg"><code>TaylorIntegration.lyap_taylorinteg</code></a></li><li><a href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any,Bool,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_taylorstep!</code></a></li><li><a href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number"><code>TaylorIntegration.nrconvergencecriterion</code></a></li><li><a href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stabilitymatrix!</code></a></li><li><a href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stepsize</code></a></li><li><a href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Tuple{Bool,Taylor1{T}},Tuple{Bool,Taylor1{T}},Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a></li><li><a href="#TaylorIntegration.taylorinteg"><code>TaylorIntegration.taylorinteg</code></a></li><li><a href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any}, Tuple{Any,Taylor1{T},Taylor1{U},T,Any,Bool}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../taylorize/">« Optimizing: <code>@taylorize</code></a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 7 March 2020 23:55">Saturday 7 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
