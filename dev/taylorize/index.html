<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing: @taylorize · TaylorIntegration.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorIntegration.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Background</span><ul><li><a class="toctext" href="../taylor_method/">ODE integration using Taylor&#39;s method</a></li><li><a class="toctext" href="../lyapunov_spectrum/">Lyapunov spectrum</a></li><li><a class="toctext" href="../jet_transport/">Jet transport</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../simple_example/">Infinity in finite time</a></li><li><a class="toctext" href="../kepler/">The Kepler problem</a></li><li><a class="toctext" href="../lorenz_lyapunov/">Lyapunov spectrum of Lorenz system</a></li><li><a class="toctext" href="../pendulum/">Jet transport: the simple pendulum</a></li><li><a class="toctext" href="../root_finding/">Poincaré maps</a></li><li><a class="toctext" href="../common/">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li class="current"><a class="toctext" href>Optimizing: <code>@taylorize</code></a><ul class="internal"><li><a class="toctext" href="#idea-1">Some context and the idea</a></li><li><a class="toctext" href="#An-example-1">An example</a></li><li><a class="toctext" href="#Limitations-1">Limitations</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Optimizing: <code>@taylorize</code></a></li></ul><a class="edit-page" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/master/docs/src/taylorize.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Optimizing: @taylorize</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="taylorize-1" href="#taylorize-1">Optimizing: <code>@taylorize</code></a></h1><p>Here, we describe the use of the macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, which parses the functions containing the ODEs to be integrated, allowing to speed up <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is still in an experimental phase; be cautious of the resulting integration, which has to be tested carefully.</p></div></div><h2><a class="nav-anchor" id="idea-1" href="#idea-1">Some context and the idea</a></h2><p>The way in which <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> works by default is by calling repeatedly the function where the ODEs of the problem are defined, in order to compute the recurrence relations that are used to construct the Taylor expansion of the solution. This is done for each order of the series in <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a>. These computations are not optimized: they waste memory due to allocations of some temporary arrays, and perform some operations whose result has been previously computed.</p><p>Here we describe one way to optimize this: The idea is to replace the default method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> by another (with the same name) which is called by dispatch, that in principle performs better. The new method is constructed specifically for the actual function defining the equations of motion by parsing its expression; the new function performs in principle <em>exactly</em> the same operations, but avoids the extra allocations and the repetition of the operations.</p><h2><a class="nav-anchor" id="An-example-1" href="#An-example-1">An example</a></h2><p>In order to explain how the macro works, we shall use as an example the <a href="../pendulum/#pendulum-1">mathematical pendulum</a>. First, we carry out the integration using the default method, as described <a href="../pendulum/#pendulum-1">before</a>.</p><div><pre><code class="language-julia">using TaylorIntegration

function pendulum!(t, x, dx)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

# Initial time (t0), final time (tf) and initial condition (q0)
t0 = 0.0
tf = 100.0
q0 = [1.3, 0.0]

# The actual integration
t1, x1 = taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500); # warm-up run
e1 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500);
e1</code></pre><pre><code class="language-none">0.021157734</code></pre></div><p>We note that the initial number of methods defined for <code>TaylorIntegration.jetcoeffs!</code> is 2.</p><div><pre><code class="language-julia">length(methods(TaylorIntegration.jetcoeffs!)) == 2 # initial value</code></pre><pre><code class="language-none">true</code></pre></div><p>Using <code>@taylorize</code> will increase this number by creating a new method.</p><p>The macro <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is intended to be used in front of the function that implements the equations of motion. The macro does the following: it first evaluates the actual function as it is, so the integration can be computed using <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> as above, or by explicitly using the keyword argument <code>parse_eqs=false</code>. It then creates and evaluates a new method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a>, which is the specialized method (through <code>Val</code>) on the specific function passed to the macro.</p><div><pre><code class="language-julia">@taylorize function pendulum!(t, x, dx)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end

println(methods(pendulum!))</code></pre><pre><code class="language-none"># 1 method for generic function &quot;pendulum!&quot;:
[1] pendulum!(t, x, dx) in Main.ex-taylorize at none:2</code></pre></div><div><pre><code class="language-julia">println(methods(TaylorIntegration.jetcoeffs!))</code></pre><pre><code class="language-none"># 3 methods for generic function &quot;jetcoeffs!&quot;:
[1] jetcoeffs!(eqsdiff::Function, t::Taylor1{T}, x::Taylor1{U}) where {T&lt;:Real, U&lt;:Number} in TaylorIntegration at /home/travis/build/PerezHz/TaylorIntegration.jl/src/explicitode.jl:24
[2] jetcoeffs!(eqsdiff!::Function, t::Taylor1{T}, x::AbstractArray{Taylor1{U},1}, dx::AbstractArray{Taylor1{U},1}, xaux::AbstractArray{Taylor1{U},1}) where {T&lt;:Real, U&lt;:Number} in TaylorIntegration at /home/travis/build/PerezHz/TaylorIntegration.jl/src/explicitode.jl:63
[3] jetcoeffs!(::Val{Main.ex-taylorize.pendulum!}, t::Taylor1{_T}, x::AbstractArray{Taylor1{_S},1}, dx::AbstractArray{Taylor1{_S},1}) where {_T&lt;:Real, _S&lt;:Number} in Main.ex-taylorize</code></pre></div><p>We see that there is only one method of <code>pendulum!</code>, and there is a new method of <code>TaylorIntegration.jetcoeffs!</code>, whose signature appears in this documentation as <code>Val{Main.ex-taylorize.pendulum!}</code>; it is an specialized version for the function <code>pendulum!</code> (with some extra information about the module where the function was created). This method is selected internally if it exists by default, exploiting dispatch, when calling <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> or <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a>; to integrate using the hard-coded method of <a href="../api/#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Function,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> of the integration above, the keyword argument <code>parse_eqs</code> has to be set to <code>false</code>.</p><p>Now we carry out the integration using the specialized method; note that we use the same instruction as above.</p><div><pre><code class="language-julia">t2, x2 = taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500); # warm-up run
e2 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500);
e2</code></pre><pre><code class="language-none">0.003349759</code></pre></div><p>We note the striking difference in the performance:</p><div><pre><code class="language-julia">e1/e2</code></pre><pre><code class="language-none">6.3161958815544645</code></pre></div><p>We can check that both integrations yield the same results.</p><div><pre><code class="language-julia">t1 == t2 &amp;&amp; x1 == x2</code></pre><pre><code class="language-none">true</code></pre></div><p>The speed-up obtained comes from the design of the new (specialized) method of <code>TaylorIntegration.jetcoeffs!</code> as described <a href="#idea-1">above</a>: it avoids some allocations and some repeated computations. This is achieved by knowing the specific AST of the function of the ODEs integrated, which is walked through and <em>translated</em> into the actual implementation, where some required auxiliary arrays are created and the low-level functions defined in <code>TaylorSeries.jl</code> are used. For this, we heavily rely on <a href="https://github.com/dfdx/Espresso.jl">Espresso.jl</a> and some metaprogramming; we thank Andrei Zhabinski for his help and comments.</p><p>The new <code>jetcoeffs!</code> method can be obtained as follows:</p><div><pre><code class="language-julia">ex = :(function pendulum!(t, x, dx)
    dx[1] = x[2]
    dx[2] = -sin(x[1])
    return dx
end)

new_ex = TaylorIntegration._make_parsed_jetcoeffs(ex)</code></pre><pre><code class="language-none">:(function TaylorIntegration.jetcoeffs!(::Val{pendulum!}, t::Taylor1{_T}, x::AbstractVector{Taylor1{_S}}, dx::AbstractVector{Taylor1{_S}}) where {_T &lt;: Real, _S &lt;: Number}
      order = t.order
      dx[1] = Taylor1(identity(constant_term(x[2])), order)
      tmp451 = Taylor1(sin(constant_term(x[1])), order)
      tmp453 = Taylor1(cos(constant_term(x[1])), order)
      dx[2] = Taylor1(-(constant_term(tmp451)), order)
      for __idx = eachindex(x)
          (x[__idx]).coeffs[2] = (dx[__idx]).coeffs[1]
      end
      for ord = 1:order - 1
          ordnext = ord + 1
          TaylorSeries.identity!(dx[1], x[2], ord)
          TaylorSeries.sincos!(tmp451, tmp453, x[1], ord)
          TaylorSeries.subst!(dx[2], tmp451, ord)
          for __idx = eachindex(x)
              (x[__idx]).coeffs[ordnext + 1] = (dx[__idx]).coeffs[ordnext] / ordnext
          end
      end
      return nothing
  end)</code></pre></div><p>This function has a similar structure as the hard-coded method of <code>TaylorIntegration.jetcoeffs!</code>, but uses low-level functions in <code>TaylorSeries</code> (e.g., <code>sincos!</code> above) and explicitly allocates the needed temporary arrays. More complex functions become easily very difficult to read. Note that, if necessary, one can further optimize <code>new_ex</code> manually.</p><p>As stated above, in order to allow to opt-out from using the specialized method created by <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a>, <a href="../api/#TaylorIntegration.taylorinteg"><code>taylorinteg</code></a> and <a href="../api/#TaylorIntegration.lyap_taylorinteg"><code>lyap_taylorinteg</code></a> recognize the keyword argument <code>parse_eqs</code>; setting it to <code>false</code> imposes using the standard method.</p><div><pre><code class="language-julia">taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500, parse_eqs=false); # warm-up run

e3 = @elapsed taylorinteg(pendulum!, q0, t0, tf, 28, 1e-20, maxsteps=1500, parse_eqs=false);</code></pre></div><div><pre><code class="language-julia">e1/e3</code></pre><pre><code class="language-none">1.7902443234461665</code></pre></div><h2><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h2><p>The construction of the function by using <a href="../api/#TaylorIntegration.@taylorize"><code>@taylorize</code></a> is somewhat complicated and limited. It is useful to have expressions which involve two arguments at most, which imposes the proper use of parenthesis: For example, <code>a+b+c</code> should be written as <code>(a+b)+c</code>. The macro allows to use array declarations through <code>Array</code>, but other ways (e.g. <code>similar</code>) are not yet implemented. It is recommended to not use variables prefixed by an underscore, in particular <code>_T</code> and <code>_S</code>, to avoid name collisions. Broadcasting is not recognized by <code>@taylorize</code>, and the macro can&#39;t be used when the integration is performed through the <a href="../common/#diffeqinterface-1">interoperability with <code>DifferentialEquations.jl</code></a>. <code>if-else</code> blocks are recognized in its long form, but short-circuit conditional operators (<code>&amp;&amp;</code> and <code>||</code>) are not. Expressions which correspond to function calls (so the <code>head</code> field is <code>:call</code>) which are not recognized by the parser are simply copied. The heuristics used, specially for vectors, may not work for all cases.</p><p>It is recommended to skim <code>test/taylorize.jl</code>, which implements different cases, including uses of <code>local</code> for internal parameters, which in some cases adds some performance.</p><p>Please report any problems you may encounter.</p><footer><hr/><a class="previous" href="../common/"><span class="direction">Previous</span><span class="title">Interoperability with <code>DifferentialEquations.jl</code></span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
